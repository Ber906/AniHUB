<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AniHUB - Watch Anime Online</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Simplified Color Palette */
            --primary: #6366f1;
            --primary-light: #818cf8;
            --primary-dark: #4f46e5;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            
            /* Clean Background Colors */
            --bg-dark: #111827;
            --bg-primary: #1f2937;
            --bg-card: #374151;
            --bg-card-hover: #4b5563;
            
            /* Text Colors */
            --text-primary: #f9fafb;
            --text-secondary: #d1d5db;
            --text-muted: #9ca3af;
            
            /* Borders */
            --border: #374151;
            --border-light: #4b5563;
            
            /* Simple Values */
            --radius: 8px;
            --transition: all 0.2s ease;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
            min-height: 100vh;
        }

        /* Simple Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border);
            z-index: 1000;
        }

        .nav {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 2rem;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.6rem;
            font-weight: 800;
            color: var(--text-primary);
            text-decoration: none;
        }

        .logo-icon {
            width: 40px;
            height: 40px;
            background: var(--primary);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }

        .nav-links {
            display: flex;
            list-style: none;
            gap: 2.5rem;
            align-items: center;
            position: relative;
        }

        .nav-link {
            color: var(--text-secondary);
            text-decoration: none;
            font-weight: 600;
            padding: 0.75rem 1.25rem;
            border-radius: 6px;
            background: transparent;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: color 0.2s ease;
        }
        
        .nav-link:hover {
            color: var(--primary);
            background: var(--bg-card);
        }
        
        .nav-link.active {
            color: var(--text-primary);
            background: var(--bg-card);
        }

        .search-container {
            position: relative;
            flex: 1;
            max-width: 400px;
        }

        .search-input {
            width: 100%;
            padding: 0.75rem 1rem 0.75rem 2.5rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.95rem;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .search-icon {
            position: absolute;
            left: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-muted);
        }

        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(10, 10, 20, 0.95);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 20px;
            margin-top: 1rem;
            max-height: 65vh;
            overflow-y: auto;
            z-index: 9999;
            display: none;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
        }

        .search-result {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 1rem;
            background: var(--bg-card);
            transition: background-color 0.2s ease;
        }

        .search-result:hover {
            background: var(--bg-card-hover);
        }

        .search-result:last-child {
            border-bottom: none;
        }

        .search-result-image {
            width: 48px;
            height: 64px;
            border-radius: 12px;
            object-fit: cover;
            background: var(--bg-light);
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.15s ease;
            position: relative;
            z-index: 2;
        }
        
        .search-result:hover .search-result-image {
            transform: none;
            border-color: var(--primary);
        }

        .search-result-info {
            position: relative;
            z-index: 2;
        }
        
        .search-result-info h4 {
            font-size: 0.95rem;
            font-weight: 700;
            color: #ffffff;
            margin-bottom: 0.25rem;
            transition: color 0.3s ease;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .search-result:hover .search-result-info h4 {
            color: var(--primary);
        }

        .search-result-info p {
            font-size: 0.8rem;
            color: #b8c5d6;
            padding: 0.25rem 0.5rem;
            background: rgba(102, 126, 234, 0.2);
            border-radius: 6px;
            border: 1px solid rgba(102, 126, 234, 0.3);
            display: inline-block;
            font-weight: 500;
        }

        .mobile-menu {
            display: none;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 1.25rem;
            cursor: pointer;
            padding: 0.75rem;
            transition: border-color 0.2s ease;
        }
        
        .mobile-menu:hover {
            border-color: var(--primary);
        }

        /* Main Content */
        .main {
            margin-top: 70px;
            min-height: calc(100vh - 70px);
        }

        /* Hero Section */
        .hero {
            padding: 3rem 1rem;
            text-align: center;
            background: var(--bg-primary);
            min-height: 40vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        

        .hero-content {
            max-width: 800px;
            margin: 0 auto;
        }

        .hero-title {
            font-size: clamp(3rem, 6vw, 5rem);
            font-weight: 900;
            color: var(--text-primary);
            margin-bottom: 1.5rem;
        }
        

        .hero-subtitle {
            font-size: clamp(1.1rem, 2.5vw, 1.4rem);
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 3rem;
            max-width: 700px;
            margin-left: auto;
            margin-right: auto;
            position: relative;
            z-index: 2;
            text-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            line-height: 1.7;
            font-weight: 400;
        }
        

        .hero-search {
            max-width: 500px;
            margin: 0 auto;
            position: relative;
        }

        .hero-search-input {
            width: 100%;
            padding: 1rem 1.5rem 1rem 3rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 1.1rem;
        }

        .hero-search-input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .hero-search-icon {
            position: absolute;
            left: 1.25rem;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 1.2rem;
            transition: all 0.15s ease;
            z-index: 3;
        }
        
        .hero-search:hover .hero-search-icon {
            color: white;
        }

        /* Introduction Section */
        .intro-section {
            padding: 4rem 1rem;
            background: var(--bg-dark);
            position: relative;
            overflow: hidden;
        }
        
        .intro-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 50%, rgba(102, 126, 234, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(240, 147, 251, 0.05) 0%, transparent 50%);
        }

        .intro-content {
            max-width: 1000px;
            margin: 0 auto;
            text-align: center;
            position: relative;
            z-index: 1;
        }

        .intro-title {
            font-size: clamp(2rem, 5vw, 2.5rem);
            font-weight: 800;
            color: var(--text-primary);
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #ffffff 0%, rgba(255, 255, 255, 0.8) 50%, var(--primary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .intro-description {
            font-size: 1.1rem;
            color: var(--text-secondary);
            line-height: 1.8;
            margin-bottom: 3rem;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        .features-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 2rem;
            margin-top: 3rem;
        }

        .feature-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            transition: border-color 0.2s ease;
        }

        .feature-card:hover {
            border-color: var(--primary);
        }

        .feature-icon {
            width: 60px;
            height: 60px;
            margin: 0 auto 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            background: var(--primary);
            color: white;
            font-size: 1.5rem;
        }

        .feature-card h3 {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
        }

        .feature-card p {
            color: var(--text-muted);
            line-height: 1.6;
            font-size: 0.95rem;
        }

        /* Statistics Section */
        .intro-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 2rem;
            margin-top: 4rem;
            padding: 3rem 2rem;
            background: rgba(99, 102, 241, 0.1);
            border-radius: 16px;
            border: 1px solid rgba(99, 102, 241, 0.2);
        }

        .stat-item {
            text-align: center;
            padding: 1.5rem;
        }

        .stat-number {
            font-size: 2.5rem;
            font-weight: 900;
            color: var(--primary);
            margin-bottom: 0.5rem;
            text-shadow: 0 2px 4px rgba(99, 102, 241, 0.3);
        }

        .stat-label {
            font-size: 1rem;
            color: var(--text-secondary);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        @media (max-width: 768px) {
            .intro-stats {
                grid-template-columns: repeat(2, 1fr);
                gap: 1.5rem;
                padding: 2rem 1rem;
            }
            
            .stat-number {
                font-size: 2rem;
            }
            
            .stat-label {
                font-size: 0.9rem;
            }
        }

        /* Content Sections */
        .section {
            padding: 3rem 1rem;
        }

        .section-alt {
            background: var(--bg-card);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 1.5rem;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 0 1rem;
            }
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 3rem;
            flex-wrap: wrap;
            gap: 1.5rem;
            position: relative;
        }
        
        .section-header::after {
            content: '';
            position: absolute;
            bottom: -1rem;
            left: 0;
            width: 60px;
            height: 3px;
            background: var(--gradient-primary);
            border-radius: 2px;
        }
        
        @media (max-width: 768px) {
            .section-header {
                margin-bottom: 2rem;
                gap: 1rem;
            }
        }

        .section-title {
            font-size: clamp(1.6rem, 4vw, 2.2rem);
            font-weight: 800;
            color: var(--text-primary);
            position: relative;
            padding-left: 1.5rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        

        .section-title::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 6px;
            background: var(--gradient-primary);
            border-radius: 3px;
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.4);
        }
        

        .view-all {
            background: var(--bg-glass);
            border: 2px solid var(--primary);
            color: var(--primary);
            padding: 0.75rem 1.5rem;
            border-radius: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: color 0.2s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 0.95rem;
            backdrop-filter: blur(4px);
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        

        .view-all:hover {
            color: white;
            border-color: var(--primary);
        }
        
        
        .view-all:hover i {
            transform: translateX(5px);
        }
        
        .view-all i {
            transition: transform 0.3s ease;
        }

        /* Anime Grid */
        .anime-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 2rem;
            padding: 2rem 0;
        }
        
        @media (max-width: 1200px) {
            .anime-grid {
                grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
                gap: 1.5rem;
            }
        }
        
        @media (max-width: 768px) {
            .anime-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 1rem;
                padding: 1rem 0;
            }
        }
        
        @media (max-width: 480px) {
            .anime-grid {
                grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
                gap: 0.8rem;
            }
            
            /* Better episodes spacing for small screens */
            .episodes-list-bottom {
                grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
                gap: 1.2rem;
                padding: 1.5rem 1rem;
                max-height: 200px;
            }
            
            .episode-item-bottom {
                padding: 1.2rem 0.8rem;
                min-height: 70px;
                border-radius: 12px;
            }
            
            /* Video controls improvements */
            .controls-row {
                gap: 1.8rem;
                margin-bottom: 1.5rem;
                padding: 0 0.5rem;
            }
            
            .server-controls {
                margin-bottom: 1rem;
            }
            
            .server-buttons {
                gap: 1rem;
                justify-content: space-around;
            }
            
            .server-btn {
                min-width: 85px;
                padding: 1rem 0.8rem;
                font-size: 0.85rem;
                border-radius: 12px;
            }
            
            /* Navigation buttons improvements */
            .episode-controls {
                gap: 1.5rem;
                justify-content: center;
                margin: 1.5rem 0;
                padding: 0 1rem;
            }
            
            .episode-btn {
                padding: 1rem 1.5rem;
                font-size: 0.9rem;
                min-width: 120px;
                border-radius: 12px;
            }
            
            /* Quality and subtitle controls */
            .quality-controls, .subtitle-controls {
                margin-bottom: 1.5rem;
                display: flex;
                flex-direction: column;
                gap: 0.8rem;
                align-items: center;
            }
            
            .quality-select, .subtitle-select {
                min-width: 200px;
                padding: 1rem;
                font-size: 0.9rem;
                text-align: center;
            }
            
            .control-label {
                font-size: 0.9rem;
                font-weight: 600;
            }
            
            /* Video modal padding for mobile */
            .video-modal {
                padding: 1rem 0.5rem;
            }
            
            .video-sidebar {
                padding: 1.2rem 1rem;
                margin-top: 1.5rem;
            }
            
            .episodes-panel-bottom {
                padding: 1.5rem 1rem;
                margin-top: 1.5rem;
            }
        }
        
        @media (max-width: 320px) {
            .anime-grid {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                gap: 0.6rem;
            }
            
            .container {
                padding: 0 0.5rem;
            }
            
            .hero-search-input {
                padding: 1rem 1.5rem 1rem 3rem;
                font-size: 1rem;
            }
            
            .section-header {
                margin-bottom: 1.5rem;
            }
        }

        .anime-card {
            background: var(--bg-card);
            border-radius: 8px;
            overflow: hidden;
            transition: border-color 0.2s ease;
            cursor: pointer;
            border: 1px solid var(--border);
            opacity: 0;
            position: relative;
        }
        
        @keyframes cardFloatIn {
            0% {
                opacity: 0;
                transform: translateY(40px) scale(0.95) rotateX(10deg);
            }
            60% {
                opacity: 1;
                transform: translateY(-5px) scale(1.02) rotateX(-2deg);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1) rotateX(0deg);
            }
        }

        .anime-card:hover {
            border-color: var(--primary);
        }
        


        .anime-card.loaded {
            opacity: 1;
        }

        .anime-poster {
            position: relative;
            aspect-ratio: 3/4;
            overflow: hidden;
            background: var(--bg-light);
        }

        .anime-poster img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .anime-status {
            position: absolute;
            top: 0.5rem;
            left: 0.5rem;
            background: var(--success);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            z-index: 3;
        }

        .anime-rating {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            background: rgba(0, 0, 0, 0.85);
            color: var(--warning);
            padding: 0.4rem 0.75rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            border: 2px solid rgba(255, 215, 0, 0.3);
            backdrop-filter: blur(4px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 3;
            transition: all 0.15s ease;
        }
        
        .anime-card:hover .anime-rating {
            transform: scale(1.1) translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 215, 0, 0.5);
        }

        .play-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 2;
        }

        .anime-card:hover .play-overlay {
            opacity: 1;
        }

        .play-button {
            width: 50px;
            height: 50px;
            background: white;
            border: 1px solid var(--border);
            border-radius: 50%;
            color: var(--bg-dark);
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        

        .play-button:hover {
            background: var(--primary);
            color: white;
        }

        .anime-info {
            padding: 1rem;
            position: relative;
            z-index: 2;
            background: var(--bg-card);
            border-top: 1px solid var(--border);
        }

        .anime-title {
            font-size: 1rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 0.875rem;
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .anime-meta {
            display: flex;
            align-items: center;
            gap: 1.25rem;
            margin-bottom: 1.125rem;
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-weight: 600;
        }

        .anime-genres {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
        }

        .genre-tag {
            background: var(--primary);
            color: white;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 500;
        }

        /* Video Player */
        .video-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(135deg, #0a0a14 0%, #0f0f1a 50%, #161625 100%),
                radial-gradient(circle at 20% 50%, rgba(102, 126, 234, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(240, 147, 251, 0.03) 0%, transparent 50%);
            display: none;
            z-index: 2000;
            overflow-y: auto;
            backdrop-filter: blur(4px);
        }

        .video-layout {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            max-width: 1200px;
            margin: 0 auto;
            padding: 1.5rem;
            min-height: 100vh;
            position: relative;
        }

        .video-container {
            position: relative;
            width: 100%;
            max-width: 100%;
            aspect-ratio: 16/9;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 20px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            transition: var(--transition);
        }
        
        .video-container:hover {
            border-color: rgba(102, 126, 234, 0.3);
            box-shadow: 0 25px 70px rgba(0, 0, 0, 0.5), 0 0 30px rgba(102, 126, 234, 0.2);
            transform: translateY(-2px);
        }

        .enhanced-speed-meter {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 1rem;
            margin: 1rem 0;
            transition: all 0.15s ease;
        }
        
        .enhanced-speed-meter:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(102, 126, 234, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }
        
        .speed-meter-content {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .speed-main {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--primary);
        }
        
        .speed-main i {
            font-size: 1.2rem;
            color: var(--accent);
        }
        
        .speed-details {
            display: flex;
            gap: 1.5rem;
            font-size: 0.85rem;
            color: var(--text-secondary);
            flex-wrap: wrap;
        }
        
        .speed-details span {
            padding: 0.25rem 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-weight: 500;
        }
        
        .speed-value {
            color: var(--text-primary);
            font-size: 1rem;
        }

        .buffering-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 1.5rem 2rem;
            border-radius: 16px;
            font-size: 0.9rem;
            font-weight: 600;
            z-index: 150;
            display: none;
            text-align: center;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .buffering-spinner {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            margin: 0 auto 0.75rem;
        }
        
        .buffering-spinner .box {
            width: 20px;
            height: 20px;
            background: #8b5cf6;
            border-radius: 4px;
            animation: horizontalFade 1.5s ease-in-out infinite;
        }
        
        .buffering-spinner .box:nth-child(1) {
            animation-delay: 0s;
        }
        
        .buffering-spinner .box:nth-child(2) {
            animation-delay: 0.3s;
        }
        
        .buffering-spinner .box:nth-child(3) {
            animation-delay: 0.6s;
        }

        .video-player {
            width: 100%;
            height: 100%;
            outline: none;
            border: none;
            border-radius: 20px;
            background: #000;
        }
        
        /* Enhanced video controls styling */
        .video-player::-webkit-media-controls-panel {
            background: linear-gradient(180deg, transparent 0%, rgba(0,0,0,0.9) 100%);
            border-radius: 0 0 20px 20px;
            backdrop-filter: blur(4px);
        }
        
        .video-player::-webkit-media-controls-play-button,
        .video-player::-webkit-media-controls-mute-button,
        .video-player::-webkit-media-controls-fullscreen-button {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            transition: all 0.15s ease;
            backdrop-filter: blur(4px);
        }
        
        .video-player::-webkit-media-controls-play-button:hover,
        .video-player::-webkit-media-controls-mute-button:hover,
        .video-player::-webkit-media-controls-fullscreen-button:hover {
            background: rgba(102, 126, 234, 0.8) !important;
            transform: scale(1.05) !important;
        }
        
        .video-player::-webkit-media-controls-timeline {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            height: 6px;
        }
        
        .video-player::-webkit-media-controls-current-time-display,
        .video-player::-webkit-media-controls-time-remaining-display {
            color: #ffffff;
            font-weight: 600;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }
        
        
        .video-player::-webkit-media-controls-overflow-menu-button {
            display: none !important;
        }
        
        .video-player::-webkit-media-controls-volume-slider {
            display: none !important;
        }
        
        .video-player::-webkit-media-controls-mute-button {
            display: none !important;
        }
        
        .video-player::-webkit-media-controls-toggle-closed-captions-button {
            display: none !important;
        }
        
        /* Hide download, playback speed, and picture in picture options */
        .video-player::-webkit-media-controls-download-button {
            display: none !important;
        }
        
        .video-player::-webkit-media-controls-picture-in-picture-button {
            display: none !important;
        }
        
        /* Hide playback rate button */
        .video-player::-webkit-media-controls-playback-rate-menu-button {
            display: none !important;
        }
        
        /* Force fullscreen button to be visible */
        .video-player::-webkit-media-controls-fullscreen-button {
            display: block !important;
            background: rgba(255, 255, 255, 0.1) !important;
            border-radius: 8px !important;
            transition: all 0.3s ease !important;
            opacity: 1 !important;
            visibility: visible !important;
        }

        .video-loading {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .loading-spinner {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            margin-bottom: 1rem;
        }
        
        .loading-dot {
            width: 20px;
            height: 20px;
            background: #8b5cf6;
            border-radius: 4px;
            animation: horizontalFade 1.5s ease-in-out infinite;
        }
        
        .loading-dot:nth-child(1) { animation-delay: 0s; }
        .loading-dot:nth-child(2) { animation-delay: 0.3s; }
        .loading-dot:nth-child(3) { animation-delay: 0.6s; }
        
        @keyframes horizontalFade {
            0% {
                opacity: 0.2;
                transform: scaleX(0.5);
            }
            50% {
                opacity: 1;
                transform: scaleX(1);
            }
            100% {
                opacity: 0.2;
                transform: scaleX(0.5);
            }
        }

        .loading-text {
            color: var(--primary);
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            text-align: center;
            animation: pulse 2s infinite;
        }

        .loading-status {
            color: var(--text-secondary);
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
            text-align: center;
            transition: transform 0.1s ease;
            min-height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .loading-progress {
            width: 280px;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
            position: relative;
        }
        
        .loading-progress::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transform: translateX(-100%);
            animation: shimmer 2s infinite;
        }
        
        @keyframes shimmer {
            100% { transform: translateX(300px); }
        }

        .loading-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary), var(--accent));
            width: 0%;
            transition: width 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 3px;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.4);
            position: relative;
        }
        
        .loading-progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 8px;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6));
            border-radius: 0 3px 3px 0;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .video-info {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            padding: 1.5rem;
            margin-top: 1rem;
        }

        .video-title {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            line-height: 1.3;
        }

        .video-meta {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1rem;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .controls-section {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
            margin-top: 1rem;
        }

        .video-container {
            position: relative;
            background: #000;
            border-radius: var(--radius-lg);
            overflow: hidden;
            aspect-ratio: 16/9;
        }

        .video-controls-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .video-container:hover .video-controls-overlay {
            opacity: 1;
        }

        .video-controls-top-overlay {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.7), transparent);
            padding: 0.5rem;
            pointer-events: auto;
        }

        .video-controls-bottom-overlay {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.7), transparent);
            padding: 0.5rem;
            pointer-events: auto;
        }

        .time-controls, .seek-controls, .utility-controls {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .time-display {
            color: white;
            font-family: monospace;
            font-size: 0.8rem;
            margin-left: 0.25rem;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }

        .video-ctrl-btn {
            background: rgba(0, 0, 0, 0.5);
            border: none;
            color: white;
            padding: 0.3rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.8rem;
            min-width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            backdrop-filter: blur(5px);
        }

        .video-ctrl-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .main-play-btn {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 50%;
            min-width: 45px;
            height: 45px;
            font-size: 1.2rem;
            backdrop-filter: blur(4px);
        }

        .main-play-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .btn-text {
            font-size: 0.6rem;
            position: absolute;
            bottom: 1px;
            right: 1px;
            background: rgba(255, 255, 255, 0.9);
            color: black;
            padding: 1px 2px;
            border-radius: 2px;
            font-weight: bold;
            line-height: 1;
        }

        .server-controls {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .server-label {
            color: var(--text-muted);
            font-weight: 600;
            margin-right: 0.5rem;
        }

        .server-btn {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(102, 126, 234, 0.05));
            border: 2px solid rgba(102, 126, 234, 0.2);
            color: #8b9aff;
            padding: 0.8rem 1.5rem;
            border-radius: 25px;
            cursor: pointer;
            transition: var(--transition);
            font-weight: 600;
            font-size: 0.85rem;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            backdrop-filter: blur(4px);
        }
        
        .server-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s ease;
            z-index: 1;
        }
        
        .server-btn span {
            position: relative;
            z-index: 2;
        }

        .server-btn:hover {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.25), rgba(102, 126, 234, 0.15));
            border-color: rgba(102, 126, 234, 0.4);
            color: #ffffff;
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 15px 35px rgba(102, 126, 234, 0.3), 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .server-btn:hover::before {
            left: 100%;
        }

        .server-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #667eea;
            color: white;
            box-shadow: 0 15px 35px rgba(102, 126, 234, 0.5), 0 5px 15px rgba(0, 0, 0, 0.2);
            transform: translateY(-3px) scale(1.05);
        }
        
        .server-btn.active::before {
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        }

        .episode-controls {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .episode-btn {
            background: var(--bg-light);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 0.75rem 1rem;
            border-radius: var(--radius);
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .episode-btn:hover {
            background: var(--bg-hover);
            border-color: var(--primary);
        }

        .episode-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .controls-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 2rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .server-controls, .subtitle-controls {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .control-label {
            color: var(--text-muted);
            font-size: 0.9rem;
            font-weight: 500;
            min-width: 70px;
        }

        .server-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .subtitle-controls, .quality-controls {
            margin-bottom: 0;
        }

        .subtitle-select, .quality-select {
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: 10px;
            color: var(--text-primary);
            padding: 0.6rem 0.8rem;
            font-size: 0.9rem;
            min-width: 150px;
            cursor: pointer;
            transition: all 0.15s ease;
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        
        .subtitle-select:hover, .quality-select:hover {
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }

        .subtitle-select:focus, .quality-select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }

        .quality-select option, .subtitle-select option {
            background: var(--bg-card);
            color: var(--text-primary);
            padding: 0.5rem;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            .controls-row {
                flex-direction: column;
                gap: 1rem;
                align-items: stretch;
            }

            .server-controls, .subtitle-controls {
                justify-content: space-between;
                width: 100%;
            }

            .control-label {
                min-width: auto;
            }

            .server-buttons {
                flex: 1;
                justify-content: flex-end;
            }

            .subtitle-select {
                flex: 1;
                max-width: 200px;
            }
        }

        .close-video {
            position: fixed;
            top: 1.5rem;
            right: 1.5rem;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9) 0%, rgba(22, 22, 37, 0.9) 100%);
            border: 2px solid rgba(255, 255, 255, 0.15);
            color: white;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            transition: color 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2001;
            backdrop-filter: blur(25px);
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .close-video:hover {
            background: linear-gradient(135deg, rgba(255, 0, 0, 0.9) 0%, rgba(200, 0, 0, 0.9) 100%);
            border-color: rgba(255, 255, 255, 0.3);
            transform: scale(1.15) rotate(90deg);
            box-shadow: 
                0 12px 35px rgba(255, 0, 0, 0.4),
                0 0 0 4px rgba(255, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        /* Episodes Sidebar */
        .episodes-panel {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            margin-top: 1rem;
            overflow: hidden;
        }

        .episodes-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .episodes-title {
            font-size: 1rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .episodes-count {
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        .episodes-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .episode-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: var(--transition);
        }

        .episode-item:hover {
            background: var(--bg-hover);
        }

        .episode-item.active {
            background: rgba(99, 102, 241, 0.1);
            border-left: 4px solid var(--primary);
        }

        .episode-item:last-child {
            border-bottom: none;
        }

        .episode-number {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .episode-title {
            color: var(--text-secondary);
            font-size: 0.8rem;
            line-height: 1.3;
            flex: 1;
        }

        /* Enhanced Loading States */
        .loading-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 4rem;
            color: var(--text-muted);
            background: linear-gradient(145deg, var(--bg-glass), rgba(255, 255, 255, 0.02));
            border-radius: 20px;
            margin: 2rem 0;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            position: relative;
        }

        .loading-state .loading-spinner {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            margin-bottom: 1.5rem;
        }
        
        
        

        .error-state {
            text-align: center;
            padding: 3rem 1rem;
            color: var(--text-muted);
        }

        .error-state i {
            font-size: 2rem;
            color: var(--error);
            margin-bottom: 1rem;
        }

        /* Responsive Design */
        @media (min-width: 768px) {
            .anime-grid {
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            }

            .controls-section {
                grid-template-columns: 1fr 1fr;
                align-items: center;
            }

            .episodes-list {
                max-height: 400px;
            }
        }

        /* Episodes Panel at Bottom */
        .episodes-panel-bottom {
            background: var(--surface);
            border-radius: var(--radius-lg);
            padding: 1.5rem;
            margin-top: 1rem;
        }

        .episodes-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 1rem;
        }

        .episodes-title {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .episodes-count {
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        .close-modal-btn {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(239, 68, 68, 0.05));
            border: 2px solid rgba(239, 68, 68, 0.3);
            color: #ef4444;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.15s ease;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .close-modal-btn:hover {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.25), rgba(239, 68, 68, 0.15));
            border-color: rgba(239, 68, 68, 0.5);
            color: #ffffff;
            transform: translateY(-2px);
        }

        .episodes-list-bottom {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 0.75rem;
            max-height: 300px;
            overflow-y: auto;
            padding: 0.5rem;
        }

        @media (min-width: 1024px) {
            .anime-grid {
                grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            }

            .video-info {
                margin-top: 0;
            }

            .episodes-list-bottom {
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
                max-height: 350px;
            }
        }

        @media (max-width: 768px) {
            /* Better episodes layout for mobile */
            .episodes-list-bottom {
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
                gap: 1rem;
                padding: 1rem;
                max-height: 250px;
            }
            
            .episode-item-bottom {
                padding: 1rem 0.75rem;
                min-height: 60px;
            }
            
            /* Better video controls spacing */
            .controls-row {
                gap: 1.5rem;
                margin-bottom: 1rem;
            }
            
            .server-buttons {
                gap: 0.75rem;
                justify-content: center;
                flex-wrap: wrap;
            }
            
            .server-btn {
                min-width: 80px;
                padding: 0.75rem 1rem;
                font-size: 0.9rem;
            }
            
            /* Video modal improvements for mobile */
            .video-modal {
                padding: 0.5rem;
            }
            
            .video-sidebar {
                padding: 1rem;
                margin-top: 1rem;
            }
            
            .nav {
                padding: 0.75rem 1rem;
                flex-wrap: nowrap;
                gap: 1rem;
                position: relative;
                justify-content: space-between;
            }
            
            .search-container {
                order: -1;
                flex: 1;
                max-width: calc(100% - 120px);
            }

            .nav-links {
                position: absolute;
                top: calc(100% + 1px);
                right: 0;
                width: 320px;
                max-height: 80vh;
                overflow-y: auto;
                background: var(--bg-primary);
                border: 1px solid var(--border);
                border-radius: 8px;
                flex-direction: column;
                padding: 1rem 0;
                z-index: 1000;
                transform: translateY(10px);
                opacity: 0;
                visibility: hidden;
                transition: all 0.2s ease;
            }
            


            .nav-links.show {
                display: flex;
                transform: translateY(0);
                opacity: 1;
                visibility: visible;
            }

            .nav-links li {
                margin: 0;
            }

            .mobile-menu-section {
                padding: 1rem;
                margin-bottom: 0.5rem;
                display: flex;
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .mobile-menu-section li {
                display: flex;
                width: 100%;
            }
            
            .mobile-menu-section .nav-link {
                width: 100%;
                justify-content: flex-start;
                padding: 0.875rem 1rem;
                margin: 0;
                border-radius: 6px;
                background: var(--bg-card);
                border: 1px solid var(--border);
                transition: all 0.2s ease;
                font-size: 0.9rem;
                font-weight: 500;
                display: flex;
                align-items: center;
                text-decoration: none;
                color: var(--text-secondary);
            }
            
            .mobile-menu-section .nav-link:hover {
                border-color: var(--primary);
                background: var(--bg-card-hover);
                color: var(--text-primary);
                transform: translateX(4px);
            }

            .mobile-menu-section .nav-link.active {
                border-color: var(--primary);
                background: rgba(99, 102, 241, 0.1);
                color: var(--primary);
            }

            .mobile-menu-title {
                font-size: 0.8rem;
                font-weight: 600;
                color: var(--text-secondary);
                text-transform: uppercase;
                letter-spacing: 0.05em;
                margin-bottom: 0.5rem;
                padding: 0 1rem;
            }

            .nav-links .nav-link {
                display: flex;
                align-items: center;
                gap: 0.75rem;
                padding: 0.875rem 1rem;
                color: var(--text-secondary);
                text-decoration: none;
                font-weight: 500;
                font-size: 0.9rem;
                transition: color 0.2s ease;
                border-radius: 6px;
                margin: 0;
            }

            .recently-played-item {
                display: flex;
                align-items: center;
                gap: 1rem;
                padding: 0.875rem 1rem;
                color: var(--text-secondary);
                text-decoration: none;
                transition: color 0.2s ease;
                border-radius: 6px;
                margin: 0 0 0.25rem;
                cursor: pointer;
                border: 1px solid var(--border);
                background: var(--bg-card);
            }
            
            .recently-played-item:hover {
                border-color: var(--primary);
                background: var(--bg-card-hover);
                color: var(--text-primary);
            }

            @keyframes slideInFromLeft {
                from {
                    opacity: 0;
                    transform: translateX(-20px);
                }
                to {
                    opacity: 1;
                    transform: translateX(0);
                }
            }


            @keyframes fadeInUp {
                from {
                    opacity: 0;
                    transform: translateY(30px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }

            @keyframes pulse {
                0%, 100% {
                    opacity: 1;
                }
                50% {
                    opacity: 0.7;
                }
            }

            .recently-played-poster {
                width: 40px;
                height: 56px;
                border-radius: 10px;
                object-fit: cover;
                background: var(--bg-light);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                transition: all 0.15s ease;
                border: 2px solid rgba(255, 255, 255, 0.1);
            }

            .recently-played-info {
                flex: 1;
                min-width: 0;
            }

            .recently-played-title {
                font-size: 0.85rem;
                font-weight: 600;
                color: var(--text-primary);
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                margin-bottom: 0.25rem;
                transition: color 0.3s ease;
            }

            .recently-played-episode {
                font-size: 0.75rem;
                color: var(--text-muted);
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                padding: 0.25rem 0.5rem;
                background: rgba(102, 126, 234, 0.1);
                border-radius: 6px;
                border: 1px solid rgba(102, 126, 234, 0.2);
                font-weight: 500;
                display: inline-block;
            }


            .nav-links .nav-link:hover {
                background: var(--bg-card-hover);
                color: var(--primary);
            }
            
            .nav-links .nav-link.active {
                background: var(--gradient-primary);
                color: white;
                transform: translateX(0) scale(1.02);
                box-shadow: 0 6px 20px rgba(102, 126, 234, 0.3);
            }

            .recently-played-item:hover {
                background: var(--bg-glass-hover);
                color: var(--text-primary);
                transform: translateX(5px) scale(1.03);
                box-shadow: 0 8px 25px rgba(79, 172, 254, 0.2);
                border-color: rgba(79, 172, 254, 0.3);
            }
            
            .recently-played-item:hover::before {
                left: 0;
            }
            
            .recently-played-item:hover .recently-played-poster {
                transform: scale(1.1) rotate(2deg);
                box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
            }
            
            .recently-played-item:hover .recently-played-title {
                color: var(--primary);
            }

            .nav-links .nav-link i {
                width: 20px;
                text-align: center;
                font-size: 0.9rem;
            }

            .nav-links .nav-link::after {
                display: none;
            }

            .nav-links .user-menu {
                margin-left: 0;
                padding: 1rem;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
                margin-top: 1rem;
                opacity: 0;
                transform: translateX(-30px);
                background: var(--bg-glass);
                border-radius: 16px;
                margin: 1rem;
                border: 1px solid rgba(255, 255, 255, 0.08);
            }

            .nav-links .user-menu .user-avatar {
                margin-bottom: 1rem;
                width: 50px;
                height: 50px;
                margin: 0 auto 1rem;
                box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            }

            .nav-links .user-menu .user-dropdown {
                position: static;
                display: block !important;
                background: none;
                border: none;
                box-shadow: none;
                padding: 0;
                margin: 0;
                text-align: center;
            }

            .nav-links .user-menu .user-dropdown-item {
                padding: 0.75rem 1rem;
                font-size: 0.9rem;
                color: var(--text-secondary);
                border-radius: 12px;
                margin-bottom: 0.5rem;
                transition: all 0.15s ease;
                display: flex;
                align-items: center;
                gap: 0.75rem;
                justify-content: center;
            }

            .nav-links .user-menu .user-dropdown-item:hover {
                color: var(--primary);
                background: var(--bg-glass-hover);
                transform: scale(1.02);
            }

            .nav-links .user-menu .user-dropdown-item.logout {
                border-top: 1px solid rgba(255, 255, 255, 0.1);
                margin-top: 0.5rem;
                padding-top: 1rem;
                color: #ef4444;
                background: rgba(239, 68, 68, 0.1);
                border: 1px solid rgba(239, 68, 68, 0.3);
            }
            
            .nav-links .user-menu .user-dropdown-item.logout:hover {
                background: rgba(239, 68, 68, 0.2);
                color: #fff;
            }

            .mobile-menu {
                display: flex;
                z-index: 1001;
                align-items: center;
                justify-content: center;
                min-width: 44px;
                height: 44px;
            }


            .search-container.collapsed {
                width: 40px;
                height: 40px;
            }

            .search-container.expanded {
                flex: 1;
                max-width: none;
                order: 3;
                width: 100%;
            }

            .hero {
                padding: 4rem 1rem;
                min-height: 50vh;
            }

            .hero-title {
                font-size: clamp(2rem, 8vw, 3rem);
                margin-bottom: 1rem;
            }

            .section {
                padding: 2rem 1rem;
            }

            .section-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 1rem;
            }

            .anime-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 1rem;
            }

            .anime-card {
                min-height: auto;
            }

            .anime-poster {
                aspect-ratio: 3/4;
            }

            .anime-info {
                padding: 0.75rem;
            }

            .anime-title {
                font-size: 0.85rem;
                line-height: 1.3;
                -webkit-line-clamp: 2;
            }

            .anime-meta {
                font-size: 0.75rem;
                margin-bottom: 0.5rem;
            }

            .genre-tag {
                font-size: 0.65rem;
                padding: 0.1rem 0.4rem;
            }

            .episode-controls {
                justify-content: center;
                flex-wrap: wrap;
            }

            .server-controls {
                justify-content: center;
                flex-wrap: wrap;
            }

            .video-layout {
                padding: 1rem;
                gap: 1rem;
            }
            
            .close-video {
                top: 1rem;
                right: 1rem;
                width: 50px;
                height: 50px;
                font-size: 1rem;
            }
            
            .video-container {
                border-radius: 16px;
            }

            .video-info {
                padding: 1rem;
            }

            .video-title {
                font-size: 1.1rem;
            }

            .controls-section {
                gap: 1rem;
            }
        }

        /* Auth Modal */
        .auth-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, 
                rgba(0, 0, 0, 0.95), 
                rgba(30, 30, 60, 0.98),
                rgba(99, 102, 241, 0.1)
            );
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            backdrop-filter: blur(30px);
            padding: 1rem;
            animation: authModalShow 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes authModalShow {
            from {
                opacity: 0;
                backdrop-filter: blur(0px);
            }
            to {
                opacity: 1;
                backdrop-filter: blur(30px);
            }
        }

        .auth-container {
            background: linear-gradient(145deg, 
                var(--bg-card) 0%, 
                rgba(255, 255, 255, 0.02) 50%,
                var(--bg-light) 100%
            );
            border-radius: 24px;
            padding: 0;
            width: 100%;
            max-width: 950px;
            border: 2px solid rgba(99, 102, 241, 0.3);
            box-shadow: 
                0 30px 60px rgba(0, 0, 0, 0.7),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            overflow: hidden;
            display: grid;
            grid-template-columns: 1fr 1fr;
            min-height: 550px;
            animation: authContainerSlide 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes authContainerSlide {
            from {
                opacity: 0;
                transform: scale(0.85) translateY(50px) rotateX(10deg);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0) rotateX(0deg);
            }
        }

        .auth-left {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            padding: 3rem 2rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .auth-left::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 100%;
            height: 200%;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="25" cy="25" r="1" fill="white" opacity="0.1"/><circle cx="75" cy="75" r="1.5" fill="white" opacity="0.08"/><circle cx="50" cy="10" r="0.5" fill="white" opacity="0.15"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>');
            opacity: 0.3;
            animation: float 20s infinite linear;
        }

        @keyframes float {
            0% { transform: translateY(0px) rotate(0deg); }
            100% { transform: translateY(-100px) rotate(360deg); }
        }

        .auth-hero {
            position: relative;
            z-index: 2;
            text-align: center;
        }

        .auth-hero-title {
            font-size: 3.2rem;
            font-weight: 900;
            color: white;
            margin-bottom: 1.5rem;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            background: linear-gradient(135deg, white, rgba(255, 255, 255, 0.85));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titlePulse 4s ease-in-out infinite alternate;
            letter-spacing: -0.02em;
        }

        @keyframes titlePulse {
            from {
                text-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
                transform: scale(1);
            }
            to {
                text-shadow: 0 6px 30px rgba(255, 255, 255, 0.3);
                transform: scale(1.02);
            }
        }

        .auth-hero-subtitle {
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.95);
            line-height: 1.7;
            margin-bottom: 2.5rem;
            font-weight: 400;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            opacity: 0;
            animation: subtitleFadeIn 1s ease-out 0.3s forwards;
        }

        @keyframes subtitleFadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .auth-features {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .auth-feature {
            display: flex;
            align-items: center;
            gap: 1rem;
            color: rgba(255, 255, 255, 0.95);
            margin-bottom: 1.25rem;
            font-size: 1rem;
            opacity: 0;
            animation: featureSlideIn 0.6s ease-out forwards;
        }

        .auth-feature:nth-child(1) { animation-delay: 0.6s; }
        .auth-feature:nth-child(2) { animation-delay: 0.8s; }
        .auth-feature:nth-child(3) { animation-delay: 1s; }

        @keyframes featureSlideIn {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .auth-feature i {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.1));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .auth-right {
            padding: 3.5rem 2.5rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            background: rgba(255, 255, 255, 0.02);
            backdrop-filter: blur(4px);
        }

        .auth-tabs {
            display: flex;
            background: var(--bg-light);
            border-radius: 12px;
            padding: 0.25rem;
            margin-bottom: 2rem;
            border: 1px solid var(--border);
        }

        .auth-tab {
            flex: 1;
            padding: 0.75rem 1rem;
            background: none;
            border: none;
            border-radius: 8px;
            color: var(--text-muted);
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: var(--transition);
        }

        .auth-tab.active {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            box-shadow: 0 2px 10px rgba(99, 102, 241, 0.3);
        }

        .auth-form {
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
        }

        .form-group {
            position: relative;
        }

        .form-input {
            width: 100%;
            padding: 1.25rem 1.25rem 1.25rem 3.5rem;
            background: rgba(255, 255, 255, 0.06);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            color: var(--text-primary);
            font-size: 1rem;
            transition: var(--transition);
            backdrop-filter: blur(6px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .form-input:focus {
            outline: none;
            border-color: var(--primary);
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 
                0 0 0 4px rgba(99, 102, 241, 0.15),
                0 8px 25px rgba(99, 102, 241, 0.15),
                0 4px 15px rgba(0, 0, 0, 0.1);
            transform: translateY(-2px);
        }

        .form-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
            font-weight: 400;
        }

        .form-icon {
            position: absolute;
            left: 1rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-muted);
            font-size: 1rem;
            transition: var(--transition);
        }

        .form-input:focus + .form-icon {
            color: var(--primary);
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .auth-button {
            background: linear-gradient(135deg, 
                var(--primary) 0%, 
                var(--secondary) 50%,
                #8b5cf6 100%
            );
            color: white;
            border: none;
            padding: 1.25rem 1.75rem;
            border-radius: 16px;
            font-weight: 700;
            font-size: 1.1rem;
            cursor: pointer;
            transition: var(--transition);
            margin-top: 1.5rem;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 8px 25px rgba(99, 102, 241, 0.3),
                0 4px 15px rgba(0, 0, 0, 0.2);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            width: 100%;
        }

        .auth-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .auth-button:hover::before {
            left: 100%;
        }

        .auth-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(99, 102, 241, 0.4);
        }

        .auth-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .auth-error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--error);
            border-radius: 10px;
            color: var(--error);
            padding: 0.875rem 1rem;
            font-size: 0.9rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .auth-success {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid var(--success);
            border-radius: 10px;
            color: var(--success);
            padding: 0.875rem 1rem;
            font-size: 0.9rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .intro-section {
                padding: 2rem 1rem;
            }
            
            .intro-description {
                font-size: 1rem;
                margin-bottom: 2rem;
            }
            
            .features-grid {
                grid-template-columns: 1fr;
                gap: 1.5rem;
                margin-top: 2rem;
            }
            
            .feature-card {
                padding: 1.5rem;
            }
            
            .feature-icon {
                width: 50px;
                height: 50px;
                font-size: 1.25rem;
            }
            
            .auth-container {
                grid-template-columns: 1fr;
                max-width: 400px;
                max-height: 90vh;
                overflow-y: auto;
            }
            
            .auth-left {
                padding: 2rem 1.5rem;
                min-height: 200px;
            }
            
            .auth-hero-title {
                font-size: 2rem;
            }
            
            .auth-right {
                padding: 2rem 1.5rem;
            }
            
            .form-row {
                grid-template-columns: 1fr;
            }
        }

        .user-menu {
            position: relative;
            display: block !important;
        }
        
        .nav-links .user-menu {
            margin-left: auto;
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
        }

        .user-avatar:hover {
            transform: none;
        }

        .user-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 0.5rem 0;
            margin-top: 0.5rem;
            min-width: 200px;
            box-shadow: var(--shadow-lg);
            display: none;
            z-index: 1000;
        }

        .user-dropdown.show {
            display: block;
        }

        .user-dropdown-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            color: var(--text-secondary);
            text-decoration: none;
            transition: var(--transition);
            cursor: pointer;
        }

        .user-dropdown-item:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .user-dropdown-item.logout {
            color: var(--error);
            border-top: 1px solid var(--border);
            margin-top: 0.5rem;
        }
        
        .user-dropdown-item.logout:hover {
            background: rgba(239, 68, 68, 0.1);
            color: #fff;
        }
        
        .logout-btn {
            background: transparent !important;
            border: 1px solid var(--error) !important;
            color: var(--error) !important;
            display: flex !important;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem !important;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        
        .logout-btn:hover {
            background: var(--error) !important;
            color: white !important;
            transform: translateY(-1px);
        }

        /* Hide main content when not authenticated */
        .content-locked {
            filter: blur(5px);
            user-select: none;
        }
        
        .content-locked .hero-search-input,
        .content-locked .search-input,
        .content-locked .anime-card,
        .content-locked button,
        .content-locked a {
            pointer-events: none;
        }

        /* Enhanced Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-card);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--gradient-primary);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--gradient-secondary);
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
        }
        
        /* Scroll triggered animations */
        @keyframes slideInFromBottom {
            from {
                opacity: 0;
                transform: translateY(50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes slideInFromRight {
            from {
                opacity: 0;
                transform: translateX(50px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        .section {
            animation: slideInFromBottom 0.8s ease-out;
        }
        
        .section:nth-child(even) .container {
            animation: slideInFromRight 0.8s ease-out 0.2s both;
        }
        
        /* SweetAlert custom styles */
        .anime-popup {
            border-radius: 20px !important;
            border: 1px solid rgba(102, 126, 234, 0.3) !important;
        }
        
        .anime-popup-title {
            color: #667eea !important;
            font-weight: 700 !important;
        }
        
        .recent-popup {
            border-radius: 20px !important;
            border: 1px solid rgba(102, 126, 234, 0.3) !important;
        }
        
        .recent-popup-title {
            color: #667eea !important;
            font-weight: 700 !important;
        }
        
        /* SIMPLIFIED POPUP DESIGN */
        .insane-popup {
            border-radius: 25px !important;
            border: 2px solid #667eea !important;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%) !important;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4) !important;
            backdrop-filter: blur(10px) !important;
            position: relative !important;
            overflow: hidden !important;
        }
        
        .insane-title {
            font-size: 2rem !important;
            font-weight: 800 !important;
            color: #667eea !important;
            text-shadow: 0 2px 10px rgba(102, 126, 234, 0.3) !important;
        }
        
        .insane-close {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24) !important;
            border: none !important;
            color: white !important;
            font-size: 1.2rem !important;
            width: 40px !important;
            height: 40px !important;
            border-radius: 50% !important;
            transition: all 0.3s ease !important;
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4) !important;
        }
        
        .insane-close:hover {
            transform: scale(1.1) !important;
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.6) !important;
        }
        
        .insane-content {
            padding: 0 !important;
        }
        
        .insane-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            padding: 2rem;
        }
        
        .loading-rings {
            position: relative;
            width: 80px;
            height: 80px;
        }
        
        .loading-rings div {
            position: absolute;
            border: 3px solid transparent;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: simpleRotate 1s linear infinite;
        }
        
        .loading-rings div:nth-child(1) {
            width: 60px;
            height: 60px;
        }
        
        @keyframes simpleRotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Insane Anime Grid */
        .insane-anime-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 1.5rem;
            padding: 1rem;
            max-height: 70vh;
            overflow-y: auto;
        }
        
        .insane-anime-card {
            background: rgba(102, 126, 234, 0.08);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 16px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.25s ease;
            position: relative;
            overflow: hidden;
        }
        
        .insane-anime-card:hover {
            transform: translateY(-5px);
            border-color: #667eea;
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.2);
        }
        
        @keyframes slideInUp {
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .insane-card-image {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 1rem;
        }
        
        .insane-card-image img {
            width: 100%;
            height: 240px;
            object-fit: cover;
            transition: transform 0.3s ease;
        }
        
        .insane-card-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .insane-anime-card:hover .insane-card-overlay {
            opacity: 1;
        }
        
        .insane-anime-card:hover .insane-card-image img {
            transform: scale(1.1);
        }
        
        .insane-play-btn {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.5rem;
            transform: scale(0.8);
            transition: transform 0.3s ease;
        }
        
        .insane-anime-card:hover .insane-play-btn {
            transform: scale(1);
        }
        
        .insane-card-info h4 {
            color: #ffffff;
            font-size: 1rem;
            margin-bottom: 0.5rem;
            font-weight: 600;
            line-height: 1.2;
        }
        
        .insane-card-info p {
            color: #a1a1aa;
            font-size: 0.85rem;
            margin: 0;
        }
        
        /* Error and No Data States */
        .insane-no-data, .insane-error {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 3rem;
            text-align: center;
        }
        
        .insane-no-data i, .insane-error i {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.6;
        }
        
        .insane-no-data i {
            color: #f59e0b;
        }
        
        .insane-error i {
            color: #ef4444;
        }
        
        /* Anime Details */
        .anime-details {
            display: flex;
            gap: 1.5rem;
            align-items: center;
            padding: 1rem;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 12px;
            margin: 1rem 0;
        }
        
        .anime-detail-poster {
            width: 100px;
            height: 140px;
            border-radius: 8px;
            object-fit: cover;
            border: 2px solid #667eea;
        }
        
        .anime-detail-info {
            flex: 1;
        }
        
        .anime-detail-info p {
            margin: 0.75rem 0;
            color: #e2e8f0;
            font-size: 1rem;
        }
        
        /* Recent Episodes */
        .recent-episodes-list {
            max-height: 400px;
            overflow-y: auto;
            padding: 1rem;
        }
        
        .recent-episode-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            margin-bottom: 1rem;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.15s ease;
            border: 1px solid rgba(102, 126, 234, 0.3);
            transform: translateX(-20px);
            opacity: 0;
            animation: slideInLeft 0.5s ease forwards;
        }
        
        .recent-episode-item:hover {
            background: rgba(102, 126, 234, 0.2);
            transform: translateX(5px);
        }
        
        @keyframes slideInLeft {
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .recent-episode-poster {
            width: 50px;
            height: 70px;
            border-radius: 8px;
            object-fit: cover;
        }
        
        .recent-episode-info {
            flex: 1;
        }
        
        .recent-episode-title {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #ffffff;
        }
        
        .recent-episode-number {
            font-size: 0.9rem;
            color: #a1a1aa;
            background: rgba(102, 126, 234, 0.2);
            padding: 0.25rem 0.75rem;
            border-radius: 6px;
            display: inline-block;
        }
        
        .insane-anime-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 1.5rem;
            max-height: 60vh;
            overflow-y: auto;
            padding: 1rem;
            scrollbar-width: thin;
            scrollbar-color: #667eea #1a1a2e;
        }
        
        .insane-anime-grid::-webkit-scrollbar {
            width: 8px;
        }
        
        .insane-anime-grid::-webkit-scrollbar-track {
            background: #1a1a2e;
            border-radius: 10px;
        }
        
        .insane-anime-grid::-webkit-scrollbar-thumb {
            background: linear-gradient(45deg, #667eea, #f093fb);
            border-radius: 10px;
        }
        
        .insane-anime-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 20px;
            padding: 1rem;
            cursor: pointer;
            transition: transform 0.25s ease, box-shadow 0.25s ease, border-color 0.25s ease;
            position: relative;
            overflow: hidden;
            will-change: transform;
            backdrop-filter: blur(4px);
            animation: insaneCardSlide 0.4s ease-out both;
            contain: layout style;
        }
        
        @keyframes insaneCardSlide {
            0% {
                opacity: 0;
                transform: translateY(30px) scale(0.9);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        .insane-anime-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.2), transparent);
            transition: left 0.6s ease;
        }
        
        .insane-anime-card:hover::before {
            left: 100%;
        }
        
        .insane-anime-card:hover {
            transform: translateY(-8px) scale(1.02);
            border-color: #667eea;
            box-shadow: 
                0 15px 30px rgba(0, 0, 0, 0.3),
                0 0 20px rgba(102, 126, 234, 0.2);
        }
        
        .insane-card-image {
            position: relative;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 1rem;
        }
        
        .insane-card-image img {
            width: 100%;
            height: 220px;
            object-fit: cover;
            transition: all 0.4s ease;
        }
        
        .insane-anime-card:hover .insane-card-image img {
            transform: none;
            filter: brightness(1.1);
        }
        
        .insane-card-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: all 0.15s ease;
        }
        
        .insane-anime-card:hover .insane-card-overlay {
            opacity: 1;
        }
        
        .insane-play-btn {
            width: 50px;
            height: 35px;
            border-radius: 8px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.2rem;
            transform: scale(0.9);
            transition: all 0.15s ease;
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }
        
        .insane-anime-card:hover .insane-play-btn {
            transform: scale(1);
        }
        
        @keyframes insanePlayPulse {
            0%, 100% { box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4); }
            50% { box-shadow: 0 15px 35px rgba(102, 126, 234, 0.6); }
        }
        
        .insane-card-info h4 {
            font-size: 1rem;
            font-weight: 700;
            color: #ffffff;
            margin-bottom: 0.5rem;
            text-align: center;
            line-height: 1.3;
        }
        
        .insane-card-info p {
            font-size: 0.8rem;
            color: #a1a1aa;
            text-align: center;
            background: rgba(102, 126, 234, 0.2);
            padding: 0.25rem 0.5rem;
            border-radius: 10px;
            border: 1px solid rgba(102, 126, 234, 0.3);
        }
        
        .insane-no-data, .insane-error {
            text-align: center;
            padding: 3rem 2rem;
            color: #a1a1aa;
        }
        
        .insane-no-data i, .insane-error i {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.7;
        }
        
        .insane-error {
            color: #ef4444;
        }
        
        .insane-error i {
            color: #ef4444;
        }
        
        /* CUSTOM POPUP STYLES */
        .custom-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1500;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .custom-popup-overlay.show {
            display: flex;
            opacity: 1;
        }
        
        .custom-popup {
            background: var(--bg-primary);
            border-radius: 8px;
            max-width: 95vw;
            max-height: 95vh;
            width: 800px;
            position: relative;
            overflow: hidden;
            border: 1px solid var(--border);
            transform: scale(0.95);
            opacity: 0;
            transition: all 0.2s ease;
        }
        
        .custom-popup.fullscreen {
            width: 95vw;
            height: 95vh;
        }
        
        .custom-popup.large {
            width: 900px;
            height: 700px;
        }
        
        .custom-popup.show {
            transform: scale(1);
            opacity: 1;
        }
        
        .custom-popup.hide {
            transform: scale(0.95);
            opacity: 0;
        }
        
        
        .custom-popup-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-primary);
            font-size: 1.2rem;
            width: 40px;
            height: 40px;
            border-radius: 4px;
            cursor: pointer;
            transition: border-color 0.2s ease;
            z-index: 10;
        }
        
        .custom-popup-close:hover {
            border-color: var(--primary);
        }
        
        .custom-popup-header {
            padding: 2rem 2rem 1rem;
            text-align: center;
        }
        
        .custom-popup-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .custom-popup-content {
            padding: 0 1.5rem;
            max-height: 60vh;
            overflow-y: auto;
        }
        
        .custom-popup-buttons {
            padding: 1.5rem 2rem 2rem;
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .popup-btn {
            padding: 0.75rem 1.5rem;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: border-color 0.2s ease;
            font-size: 1rem;
            background: var(--bg-card);
            color: var(--text-primary);
        }
        
        .popup-btn:hover {
            border-color: var(--primary);
        }
        
        .popup-btn.btn-primary {
            background: var(--primary);
            color: white;
        }
        
        .popup-btn.btn-secondary {
            background: var(--bg-card);
            color: var(--text-secondary);
            position: relative;
            overflow: hidden;
            will-change: transform, box-shadow;
        }
        
        .popup-btn.btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .popup-btn.btn-primary:hover {
            transform: translateY(-1px) scale(1.02);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }
        
        .popup-btn.btn-secondary {
            background: linear-gradient(45deg, #6c757d, #495057);
            color: white;
            box-shadow: 0 5px 15px rgba(108, 117, 125, 0.4);
        }
        
        .popup-btn.btn-secondary:hover {
            transform: translateY(-1px) scale(1.02);
            box-shadow: 0 6px 20px rgba(108, 117, 125, 0.5);
        }
        
        /* Anime Details Styles */
        .anime-details {
            display: flex;
            gap: 1.5rem;
            align-items: center;
        }
        
        .anime-detail-poster {
            width: 120px;
            height: 168px;
            border-radius: 15px;
            object-fit: cover;
            border: 2px solid #667eea;
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }
        
        .anime-detail-info {
            flex: 1;
        }
        
        .anime-detail-info p {
            margin: 0.75rem 0;
            color: #a1a1aa;
            font-size: 1.1rem;
        }
        
        .anime-detail-info strong {
            color: #667eea;
        }
        
        /* Recent Episodes List */
        .recent-episodes-list {
            display: grid;
            gap: 1rem;
            max-height: 50vh;
            overflow-y: auto;
        }
        
        .recent-episode-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.15s ease;
            animation: slideInUp 0.5s ease both;
            position: relative;
        }
        
        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .recent-episode-item:hover {
            background: rgba(102, 126, 234, 0.2);
            transform: translateX(10px);
        }
        
        .recent-episode-poster {
            width: 60px;
            height: 84px;
            border-radius: 10px;
            object-fit: cover;
            border: 1px solid rgba(102, 126, 234, 0.5);
        }
        
        .recent-episode-info {
            flex: 1;
        }
        
        .recent-episode-title {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #ffffff;
        }
        
        .recent-episode-number {
            font-size: 0.9rem;
            color: #a1a1aa;
            background: rgba(102, 126, 234, 0.2);
            padding: 0.25rem 0.75rem;
            border-radius: 8px;
            display: inline-block;
            margin-bottom: 0.5rem;
        }
        
        .recent-episode-progress-text {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
        }
        
        .recent-episode-progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 0.5rem;
        }
        
        .recent-episode-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        
        .resume-badge {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            color: white;
            font-size: 0.7rem;
            font-weight: 600;
            padding: 0.25rem 0.5rem;
            border-radius: 15px;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
            z-index: 10;
        }

        /* Favorites Styling */
        .favorite-btn {
            position: absolute;
            top: 0.5rem;
            left: 0.5rem;
            width: 35px;
            height: 35px;
            background: rgba(0, 0, 0, 0.7);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
            backdrop-filter: blur(5px);
        }

        .favorite-btn:hover {
            background: rgba(0, 0, 0, 0.9);
            transform: scale(1.1);
        }

        .favorite-btn.favorited {
            background: rgba(255, 20, 147, 0.9);
            color: white;
        }

        .favorite-btn.favorited:hover {
            background: rgba(255, 20, 147, 1);
        }

        .favorites-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            max-height: 50vh;
            overflow-y: auto;
        }

        .favorite-anime-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 15px;
            transition: all 0.15s ease;
            animation: slideInUp 0.5s ease both;
        }

        .favorite-anime-item:hover {
            background: rgba(102, 126, 234, 0.2);
            transform: translateX(5px);
        }

        .favorite-anime-poster {
            width: 60px;
            height: 84px;
            border-radius: 10px;
            object-fit: cover;
            border: 1px solid rgba(102, 126, 234, 0.5);
        }

        .favorite-anime-info {
            flex: 1;
        }

        .favorite-anime-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
            line-height: 1.3;
        }

        .favorite-anime-details {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 0.75rem;
        }

        .favorite-anime-actions {
            display: flex;
            gap: 0.5rem;
        }

        .favorite-anime-actions .btn-primary,
        .favorite-anime-actions .btn-secondary {
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
            border-radius: 8px;
        }


        /* Auto-play Countdown */
        .autoplay-countdown {
            position: fixed;
            bottom: 100px;
            right: 30px;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(102, 126, 234, 0.5);
            border-radius: 15px;
            padding: 1.5rem;
            color: white;
            z-index: 1000;
            min-width: 300px;
            animation: slideInUp 0.3s ease;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        .autoplay-content {
            text-align: center;
        }

        .autoplay-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--primary);
        }

        .autoplay-info {
            margin-bottom: 1.5rem;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .autoplay-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .autoplay-actions button {
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        #countdownTime {
            color: var(--accent);
            font-weight: 700;
            font-size: 1.2em;
        }

        /* Enhanced SweetAlert Styling */
        .swal2-popup {
            background: linear-gradient(145deg, #1a1a2e 0%, #16213e 100%) !important;
            border: 1px solid var(--primary) !important;
            border-radius: 20px !important;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5), 0 0 40px rgba(99, 102, 241, 0.3) !important;
            color: var(--text-primary) !important;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif !important;
            animation: swalFadeIn 0.4s ease-out !important;
        }

        .swal2-title {
            color: var(--text-primary) !important;
            font-size: 1.8rem !important;
            font-weight: 700 !important;
            margin-bottom: 0.8rem !important;
            text-shadow: 0 2px 10px rgba(99, 102, 241, 0.3) !important;
        }

        .swal2-content {
            color: var(--text-secondary) !important;
            font-size: 1.1rem !important;
            font-weight: 400 !important;
            line-height: 1.6 !important;
        }

        .swal2-icon.swal2-success {
            border-color: #10b981 !important;
            color: #10b981 !important;
            animation: swalSuccessIcon 0.6s ease-out !important;
        }

        .swal2-icon.swal2-success [class^='swal2-success-line'] {
            background-color: #10b981 !important;
        }

        .swal2-icon.swal2-success .swal2-success-ring {
            border-color: #10b981 !important;
        }

        .swal2-confirm {
            background: linear-gradient(135deg, var(--primary) 0%, #4f46e5 100%) !important;
            border: none !important;
            border-radius: 12px !important;
            padding: 12px 32px !important;
            font-size: 1rem !important;
            font-weight: 600 !important;
            color: white !important;
            box-shadow: 0 8px 20px rgba(99, 102, 241, 0.4) !important;
            transition: all 0.3s ease !important;
            text-transform: uppercase !important;
            letter-spacing: 0.5px !important;
        }

        .swal2-confirm:hover {
            transform: translateY(-2px) !important;
            box-shadow: 0 12px 30px rgba(99, 102, 241, 0.6) !important;
            background: linear-gradient(135deg, #4f46e5 0%, var(--primary) 100%) !important;
        }

        .swal2-confirm:focus {
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.4) !important;
        }

        .swal2-backdrop {
            background: rgba(0, 0, 0, 0.8) !important;
            backdrop-filter: blur(8px) !important;
        }

        @keyframes swalFadeIn {
            from {
                opacity: 0;
                transform: scale(0.8) translateY(-20px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        @keyframes swalSuccessIcon {
            0% {
                transform: scale(0);
                opacity: 0;
            }
            50% {
                transform: scale(1.2);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .swal2-icon.swal2-success::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(16, 185, 129, 0.1);
            animation: swalSuccessPulse 2s infinite;
        }

        @keyframes swalSuccessPulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.1);
                opacity: 0.7;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Enhanced Error Alert */
        .swal2-icon.swal2-error {
            border-color: #ef4444 !important;
            color: #ef4444 !important;
        }

        .swal2-icon.swal2-error [class^='swal2-x-mark-line'] {
            background-color: #ef4444 !important;
        }

        /* Enhanced Warning Alert */
        .swal2-icon.swal2-warning {
            border-color: #f59e0b !important;
            color: #f59e0b !important;
        }

        /* Enhanced Info Alert */
        .swal2-icon.swal2-info {
            border-color: var(--primary) !important;
            color: var(--primary) !important;
        }

        /* User Statistics */
        .user-stats {
            max-width: 100%;
        }

        .user-stats-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 15px;
            border: 1px solid rgba(102, 126, 234, 0.3);
        }

        .user-avatar-large {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: 700;
            color: white;
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        .user-info h3 {
            margin: 0 0 0.5rem 0;
            color: var(--text-primary);
            font-size: 1.5rem;
            font-weight: 600;
        }

        .user-info p {
            margin: 0;
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: rgba(102, 126, 234, 0.05);
            border: 1px solid rgba(102, 126, 234, 0.2);
            border-radius: 15px;
            padding: 1.5rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            transition: all 0.15s ease;
        }

        .stat-card:hover {
            background: rgba(102, 126, 234, 0.1);
            transform: translateY(-2px);
        }

        .stat-card.full-width {
            grid-column: span 2;
        }

        .stat-icon {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.2rem;
            flex-shrink: 0;
        }

        .stat-info {
            flex: 1;
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
            line-height: 1.2;
        }

        .stat-label {
            font-size: 0.85rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stats-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .stats-actions button {
            padding: 0.75rem 1.5rem;
            font-size: 0.9rem;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        @media (max-width: 768px) {
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .stat-card.full-width {
                grid-column: span 1;
            }
            
            .user-stats-header {
                flex-direction: column;
                text-align: center;
            }
        }

        /* Enhanced Loading States */
        .loading-skeleton {
            background: linear-gradient(90deg, 
                rgba(102, 126, 234, 0.1) 25%, 
                rgba(102, 126, 234, 0.2) 50%, 
                rgba(102, 126, 234, 0.1) 75%
            );
            background-size: 200% 100%;
            animation: skeleton-loading 1.5s infinite;
            border-radius: 10px;
        }

        @keyframes skeleton-loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .card-skeleton {
            width: 100%;
            aspect-ratio: 3/4;
            margin-bottom: 1rem;
        }

        .text-skeleton {
            height: 1rem;
            margin-bottom: 0.5rem;
            width: 80%;
        }

        .text-skeleton.short {
            width: 60%;
        }

        /* Enhanced Animations */
        .bounce-in {
            opacity: 1;
        }

        .slide-in-up {
            animation: slideInUp 0.4s ease-out both;
        }

        .fade-in-scale {
            animation: fadeInScale 0.5s ease-out both;
        }

        @keyframes fadeInScale {
            0% {
                opacity: 0;
                transform: scale(0.8) rotate(-2deg);
            }
            100% {
                opacity: 1;
                transform: scale(1) rotate(0deg);
            }
        }

        /* Micro-interactions */
        .micro-bounce:hover {
            animation: microBounce 0.3s ease;
        }

        @keyframes microBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }

        .pulse-border {
            position: relative;
            overflow: hidden;
        }

        .pulse-border::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.4), transparent);
            transition: left 0.5s;
        }

        .pulse-border:hover::before {
            left: 100%;
        }

        /* Enhanced notification styles */
        .notification.sound-enabled {
            animation: notificationBounce 0.5s ease-out;
        }

        @keyframes notificationBounce {
            0% { transform: translateX(100%) scale(0.8); }
            60% { transform: translateX(-10px) scale(1.1); }
            100% { transform: translateX(0) scale(1); }
        }

        /* Loading indicator for video */
        .video-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
        }

        /* Keyboard shortcuts help */
        .keyboard-shortcuts-hint {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 1rem;
            border-radius: 10px;
            font-size: 0.8rem;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.15s ease;
            z-index: 1000;
            max-width: 250px;
        }

        .keyboard-shortcuts-hint.show {
            opacity: 1;
            transform: translateY(0);
        }

        .shortcut-key {
            background: rgba(255, 255, 255, 0.2);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: monospace;
            font-weight: bold;
        }
        
        .no-data {
            text-align: center;
            padding: 3rem 2rem;
            color: #a1a1aa;
        }
        
        .no-data i {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.7;
            color: #667eea;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header" id="header">
        <nav class="nav">
            <a href="#" class="logo">
                <div class="logo-icon">
                    <i class="fas fa-play"></i>
                </div>
                AniHUB
            </a>
            
            <ul class="nav-links">
                <div class="mobile-menu-section">
                    <div class="mobile-menu-title">Navigation</div>
                    <li><a href="#home" class="nav-link active">Home</a></li>
                    <li><a href="#" class="nav-link" onclick="showTrendingPopup()">Trending</a></li>
                    <li><a href="#" class="nav-link" onclick="showPopularPopup()">Popular</a></li>
                    <li><a href="#" class="nav-link" onclick="showFavoritesPopup()">Favorites</a></li>
                    <li><a href="#" class="nav-link" onclick="showRecentlyPlayedPopup()">Recently Watched</a></li>
                </div>
                
                <li class="nav-item">
                    <button class="nav-link logout-btn" onclick="logout()" title="Logout">
                        <i class="fas fa-sign-out-alt"></i>
                        <span>Logout</span>
                    </button>
                </li>
            </ul>
            
            <button class="mobile-menu" id="mobileMenu">
                <i class="fas fa-bars"></i>
            </button>
        </nav>
    </header>

    <!-- Main Content -->
    <main class="main">
        <!-- Hero Section -->
        <section class="hero" id="home">
            <div class="hero-content">
                <h1 class="hero-title">AniHUB</h1>
                <p class="hero-subtitle">Your ultimate anime streaming destination. Watch thousands of anime series and movies in high quality.</p>
                <div class="hero-search">
                    <i class="fas fa-search hero-search-icon"></i>
                    <input type="text" class="hero-search-input" placeholder="Search for anime..." id="searchInput">
                    <div class="search-results" id="searchResults"></div>
                </div>
            </div>
        </section>

        <!-- Introduction Section -->
        <section class="intro-section">
            <div class="container">
                <div class="intro-content">
                    <h2 class="intro-title">Welcome to AniHUB - Your Premier Anime Destination</h2>
                    <p class="intro-description">
                        Step into the ultimate anime streaming experience with AniHUB, where passion meets technology. Our platform is meticulously designed to bring you the most comprehensive collection of anime series and movies from across the globe. Whether you're a seasoned otaku or just beginning your anime journey, AniHUB offers an unparalleled viewing experience with crystal-clear high definition streaming, multiple server options for optimal performance, and an intuitive interface that makes discovering your next favorite anime effortless.
                    </p>
                    
                    <p class="intro-description">
                        We understand that anime is more than just entertainment—it's a culture, a passion, and a way of life. That's why we've created a platform that respects and celebrates the art of anime while providing cutting-edge streaming technology. Our extensive library spans across all genres, from classic shounen adventures to heartwarming slice-of-life stories, thrilling psychological dramas, and everything in between. With new episodes and series added regularly, you'll never run out of amazing content to explore.
                    </p>
                    
                    <div class="features-grid">
                        <div class="feature-card">
                            <div class="feature-icon">
                                <i class="fas fa-play-circle"></i>
                            </div>
                            <h3>Ultra HD Streaming</h3>
                            <p>Experience anime in stunning 4K quality with adaptive bitrate streaming that adjusts to your internet speed for seamless playback</p>
                        </div>
                        
                        <div class="feature-card">
                            <div class="feature-icon">
                                <i class="fas fa-search"></i>
                            </div>
                            <h3>Smart Discovery</h3>
                            <p>Our intelligent search engine helps you discover anime based on genres, ratings, release years, and personalized recommendations</p>
                        </div>
                        
                        <div class="feature-card">
                            <div class="feature-icon">
                                <i class="fas fa-history"></i>
                            </div>
                            <h3>Progress Tracking</h3>
                            <p>Never lose your place again with automatic episode tracking, watch history, and seamless cross-device synchronization</p>
                        </div>
                        
                        <div class="feature-card">
                            <div class="feature-icon">
                                <i class="fas fa-mobile-alt"></i>
                            </div>
                            <h3>Multi-Device Access</h3>
                            <p>Watch anywhere, anytime on your smartphone, tablet, laptop, or smart TV with our responsive design and offline download options</p>
                        </div>

                        <div class="feature-card">
                            <div class="feature-icon">
                                <i class="fas fa-heart"></i>
                            </div>
                            <h3>Personal Library</h3>
                            <p>Create custom watchlists, bookmark favorites, and get personalized recommendations based on your viewing preferences</p>
                        </div>
                        
                        <div class="feature-card">
                            <div class="feature-icon">
                                <i class="fas fa-clock"></i>
                            </div>
                            <h3>Real-Time Updates</h3>
                            <p>Stay up-to-date with the latest episodes as they air in Japan, with subtitles available in multiple languages</p>
                        </div>

                        <div class="feature-card">
                            <div class="feature-icon">
                                <i class="fas fa-shield-alt"></i>
                            </div>
                            <h3>Safe & Secure</h3>
                            <p>Enjoy ad-free streaming in a secure environment with advanced encryption and privacy protection for all users</p>
                        </div>
                        
                        <div class="feature-card">
                            <div class="feature-icon">
                                <i class="fas fa-users"></i>
                            </div>
                            <h3>Community Features</h3>
                            <p>Connect with fellow anime fans, share reviews, discuss episodes, and participate in seasonal anime discussions</p>
                        </div>
                    </div>

                    <div class="intro-stats">
                        <div class="stat-item">
                            <div class="stat-number">10,000+</div>
                            <div class="stat-label">Anime Series</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number">50,000+</div>
                            <div class="stat-label">Episodes Available</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number">99.9%</div>
                            <div class="stat-label">Uptime Guaranteed</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number">24/7</div>
                            <div class="stat-label">Support Available</div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

    </main>

    <!-- Custom Popup Modal -->
    <div class="custom-popup-overlay" id="customPopupOverlay">
        <div class="custom-popup" id="customPopup">
            <button class="custom-popup-close" onclick="closeCustomPopup()">
                <i class="fas fa-times"></i>
            </button>
            <div class="custom-popup-header">
                <h2 class="custom-popup-title" id="customPopupTitle">Title</h2>
            </div>
            <div class="custom-popup-content" id="customPopupContent">
                Content goes here
            </div>
            <div class="custom-popup-buttons" id="customPopupButtons">
                <!-- Buttons will be added dynamically -->
            </div>
        </div>
    </div>

    <!-- Video Modal -->
    <div class="video-modal" id="videoModal">
        
        <div class="video-layout">
            <div class="video-main">
                <div class="video-container">
                    <video class="video-player" id="videoPlayer" 
                           oncontextmenu="return false;" 
                           preload="metadata"
                           playsinline
                           disablePictureInPicture
                           webkit-playsinline
                           autoplay
                           muted></video>
                    
                    <!-- Video Controls Overlay -->
                    <div class="video-controls-overlay" id="videoControlsOverlay">
                        <!-- Top Controls -->
                        <div class="video-controls-top-overlay">
                            <div class="time-controls">
                                <button class="video-ctrl-btn" id="muteBtn">
                                    <i class="fas fa-volume-up"></i>
                                </button>
                                <span class="time-display" id="timeDisplay">00:00 / 00:00</span>
                            </div>
                            <div class="seek-controls">
                                <button class="video-ctrl-btn" id="rewind10Btn">
                                    <i class="fas fa-undo"></i>
                                    <span class="btn-text">10</span>
                                </button>
                                <button class="video-ctrl-btn" id="forward10Btn">
                                    <i class="fas fa-redo"></i>
                                    <span class="btn-text">10</span>
                                </button>
                            </div>
                            <div class="utility-controls">
                                <button class="video-ctrl-btn" id="downloadBtn">
                                    <i class="fas fa-download"></i>
                                </button>
                                <button class="video-ctrl-btn" id="settingsBtn">
                                    <i class="fas fa-cog"></i>
                                </button>
                                <button class="video-ctrl-btn" id="pipBtn">
                                    <i class="fas fa-external-link-alt"></i>
                                </button>
                                <button class="video-ctrl-btn" id="fullscreenBtn">
                                    <i class="fas fa-expand"></i>
                                </button>
                            </div>
                        </div>

                        <!-- Bottom Controls -->
                        <div class="video-controls-bottom-overlay">
                            <button class="video-ctrl-btn" id="fastForwardBtn">
                                <i class="fas fa-fast-forward"></i>
                            </button>
                            <button class="video-ctrl-btn main-play-btn" id="mainPlayBtn">
                                <i class="fas fa-play"></i>
                            </button>
                            <button class="video-ctrl-btn" id="speedBtn">
                                <i class="fas fa-tachometer-alt"></i>
                            </button>
                            <button class="video-ctrl-btn" id="prevBtn">
                                <i class="fas fa-step-backward"></i>
                            </button>
                            <button class="video-ctrl-btn" id="nextBtn">
                                <i class="fas fa-step-forward"></i>
                            </button>
                            <button class="video-ctrl-btn" id="favoriteBtn">
                                <i class="fas fa-heart"></i>
                            </button>
                            <button class="video-ctrl-btn" id="subtitlesBtn">
                                <i class="fas fa-closed-captioning"></i>
                            </button>
                            <button class="video-ctrl-btn" id="audioBtn">
                                <i class="fas fa-volume-up"></i>
                            </button>
                        </div>
                    </div>
                    
                    
                    
                    <div class="buffering-indicator" id="bufferingIndicator">
                        <div class="buffering-spinner">
                            <div class="box"></div>
                            <div class="box"></div>
                            <div class="box"></div>
                        </div>
                    </div>
                    
                </div>
                
                <div class="video-info">
                    <h2 class="video-title" id="videoTitle">Episode Title</h2>
                    <div class="video-meta">
                        <span id="videoEpisode">Episode 1</span>
                        <span>•</span>
                        <span id="videoDate">2024</span>
                        <span>•</span>
                        <span>24 min</span>
                    </div>
                    
                    <!-- Enhanced Speed Meter -->
                    <div class="enhanced-speed-meter" id="speedMeter" style="display: none;">
                        <div class="speed-meter-content">
                            <div class="speed-main">
                                <i class="fas fa-tachometer-alt"></i>
                                <span class="speed-value" id="speedValue">0 KB/s</span>
                            </div>
                            <div class="speed-details">
                                <span class="buffer-info" id="bufferInfo">Buffer: 0%</span>
                                <span class="quality-info" id="qualityInfo">Quality: Auto</span>
                                <span class="ping-info" id="pingInfo">Ping: -ms</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="controls-section">
                        <div class="server-controls">
                            <span class="control-label">Server:</span>
                            <div class="server-buttons">
                                <button class="server-btn active" data-server="hd-1">HD-1</button>
                                <button class="server-btn" data-server="megacloud">MegaCloud</button>
                                <button class="server-btn" data-server="hd-2">HD-2</button>
                            </div>
                        </div>

                            <div class="quality-controls" id="qualityControls" style="display: none;">
                                <span class="control-label">Quality:</span>
                                <select id="qualitySelect" class="quality-select">
                                    <option value="auto">Auto</option>
                                </select>
                            </div>

                            <div class="subtitle-controls" id="subtitleControls" style="display: none;">
                                <span class="control-label">Subtitles:</span>
                                <select id="subtitleSelect" class="subtitle-select">
                                    <option value="">No Subtitles</option>
                                </select>
                            </div>
                        </div>
                        
                        <div class="episode-controls">
                            <button class="episode-btn" id="prevEpisode">
                                <i class="fas fa-chevron-left"></i> Previous
                            </button>
                            <button class="episode-btn" id="nextEpisode">
                                Next <i class="fas fa-chevron-right"></i>
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Episodes Panel at Bottom -->
                <div class="episodes-panel-bottom">
                    <div class="episodes-header">
                        <h3 class="episodes-title">Episodes</h3>
                        <span class="episodes-count" id="episodesCount">0 episodes</span>
                        <button class="close-modal-btn" onclick="closeVideoModal()">
                            <i class="fas fa-times"></i> Close
                        </button>
                    </div>
                    <div class="episodes-list-bottom" id="episodesList">
                        <!-- Episodes will be populated here -->
                    </div>
                </div>
            </div>
            
        </div>
    </div>

    <!-- Authentication Modal -->
    <div class="auth-modal" id="authModal">
        <div class="auth-container">
            <!-- Left Side - Hero Section -->
            <div class="auth-left">
                <div class="auth-hero">
                    <h1 class="auth-hero-title">AniHUB</h1>
                    <p class="auth-hero-subtitle">Your ultimate anime streaming destination with thousands of series and movies in high quality.</p>
                    
                    <ul class="auth-features">
                        <li class="auth-feature">
                            <i class="fas fa-play"></i>
                            <span>Unlimited anime streaming</span>
                        </li>
                        <li class="auth-feature">
                            <i class="fas fa-hd-video"></i>
                            <span>HD & 4K quality videos</span>
                        </li>
                        <li class="auth-feature">
                            <i class="fas fa-mobile-alt"></i>
                            <span>Watch on any device</span>
                        </li>
                        <li class="auth-feature">
                            <i class="fas fa-bookmark"></i>
                            <span>Save your favorites</span>
                        </li>
                    </ul>
                </div>
            </div>
            
            <!-- Right Side - Form Section -->
            <div class="auth-right">
                <div class="auth-tabs">
                    <button class="auth-tab active" id="signinTab" onclick="switchToSignin()">Sign In</button>
                    <button class="auth-tab" id="signupTab" onclick="switchToSignup()">Sign Up</button>
                </div>
                
                <div id="authError" class="auth-error" style="display: none;">
                    <i class="fas fa-exclamation-circle"></i>
                    <span id="authErrorText"></span>
                </div>
                <div id="authSuccess" class="auth-success" style="display: none;">
                    <i class="fas fa-check-circle"></i>
                    <span id="authSuccessText"></span>
                </div>
                
                <form class="auth-form" id="authForm">
                    <div class="form-group" id="nameFields" style="display: none;">
                        <input type="text" class="form-input" id="username" placeholder="Username">
                        <i class="fas fa-user form-icon"></i>
                    </div>
                    
                    <div class="form-group">
                        <input type="email" class="form-input" id="email" placeholder="Email address" required>
                        <i class="fas fa-envelope form-icon"></i>
                    </div>
                    
                    <div class="form-group">
                        <input type="password" class="form-input" id="password" placeholder="Password" required>
                        <i class="fas fa-lock form-icon"></i>
                    </div>
                    
                    <button type="submit" class="auth-button" id="authSubmit">
                        <span id="authButtonText">Sign In</span>
                    </button>
                </form>
            </div>
        </div>
    </div>

    <script>
        // Enhanced global error handling to prevent script errors and unhandled rejections
        window.addEventListener('error', function(event) {
            console.error('Global JavaScript Error:', {
                message: event.message,
                filename: event.filename,
                line: event.lineno,
                column: event.colno,
                error: event.error
            });
            
            // Prevent default error handling which causes "Script error" messages
            event.preventDefault();
            return true;
        });

        // Handle unhandled promise rejections
        window.addEventListener('unhandledrejection', function(event) {
            console.error('Unhandled Promise Rejection:', {
                reason: event.reason,
                promise: event.promise,
                stack: event.reason?.stack
            });
            
            // Prevent default handling
            event.preventDefault();
        });

        // Enhanced fetch wrapper with better error handling
        async function safeFetch(url, options = {}) {
            try {
                const response = await fetch(url, {
                    ...options,
                    headers: {
                        'Content-Type': 'application/json',
                        ...options.headers
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                return await response.json();
            } catch (error) {
                console.error('Fetch Error:', error.message);
                throw error;
            }
        }

        // Global variables
        const API_BASE_URL = window.location.origin;
        console.log('API_BASE_URL set to:', API_BASE_URL);
        let currentHls = null;
        let searchTimeout = null;
        let currentAnimeId = null;
        let currentEpisodeIndex = 0;
        let episodes = [];
        let currentAnimeInfo = null;

        // Auto-play function that handles browser policies gracefully
        function tryAutoPlay(videoElement) {
            if (!videoElement) return;
            
            const playPromise = videoElement.play();
            
            if (playPromise !== undefined) {
                playPromise
                    .then(() => {
                        console.log('Auto-play started successfully');
                        // Unmute after successful auto-play if user prefers
                        if (videoElement.muted && localStorage.getItem('preferUnmuted') === 'true') {
                            videoElement.muted = false;
                        }
                    })
                    .catch((error) => {
                        console.log('Auto-play blocked by browser policy:', error);
                        // Show a subtle notification that user can click to play
                        showNotification('Click video to start playing', 'info');
                        
                        // Add click handler to unmute and play when user interacts
                        const playOnClick = () => {
                            videoElement.muted = false;
                            videoElement.play();
                            videoElement.removeEventListener('click', playOnClick);
                        };
                        videoElement.addEventListener('click', playOnClick);
                    });
            }
        }
        let currentVideoSources = [];
        let currentServer = 'hd-1';
        let speedMeterInterval = null;
        let lastBytesReceived = 0;
        
        // Global reference to buffering indicator
        let bufferingIndicator;
        let lastTime = Date.now();
        
        // Auth variables
        let currentUser = null;
        let isSignUpMode = false;

        // Global utility function with enhanced animation
        function updateLoadingStatus(message) {
            // No text display - just loading blocks animation
        }
        
        // Smooth progress bar animation
        function animateProgress(progressBar, targetWidth, duration = 300) {
            if (!progressBar) return;
            
            const currentWidth = parseFloat(progressBar.style.width) || 0;
            const difference = targetWidth - currentWidth;
            const steps = 20;
            const stepSize = difference / steps;
            const stepDuration = duration / steps;
            
            let currentStep = 0;
            const animate = () => {
                if (currentStep < steps && progressBar) {
                    const newWidth = currentWidth + (stepSize * currentStep);
                    progressBar.style.width = `${Math.min(newWidth, targetWidth)}%`;
                    currentStep++;
                    setTimeout(animate, stepDuration);
                } else if (progressBar) {
                    progressBar.style.width = `${targetWidth}%`;
                }
            };
            animate();
        }
        
        // Format speed for display
        function formatSpeed(bytesPerSecond) {
            if (bytesPerSecond < 1024) {
                return `${Math.round(bytesPerSecond)} B/s`;
            } else if (bytesPerSecond < 1024 * 1024) {
                return `${Math.round(bytesPerSecond / 1024)} KB/s`;
            } else if (bytesPerSecond < 1024 * 1024 * 1024) {
                return `${(bytesPerSecond / (1024 * 1024)).toFixed(1)} MB/s`;
            } else {
                return `${(bytesPerSecond / (1024 * 1024 * 1024)).toFixed(2)} GB/s`;
            }
        }
        
        // Get current video quality
        function getCurrentQuality() {
            const qualitySelect = document.getElementById('qualitySelect');
            if (qualitySelect && qualitySelect.value) {
                const selectedOption = qualitySelect.options[qualitySelect.selectedIndex];
                return selectedOption ? selectedOption.text : 'Auto';
            }
            return 'Auto';
        }
        
        // Format time for display
        function formatTime(seconds) {
            if (isNaN(seconds) || seconds < 0) return '0:00';
            
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            
            if (hours > 0) {
                return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            } else {
                return `${minutes}:${secs.toString().padStart(2, '0')}`;
            }
        }
        
        // Setup custom video controls for enhanced UX
        function setupCustomVideoControls(videoPlayer) {
            // Get all video control elements
            const muteBtn = document.getElementById('muteBtn');
            const timeDisplay = document.getElementById('timeDisplay');
            const rewind10Btn = document.getElementById('rewind10Btn');
            const forward10Btn = document.getElementById('forward10Btn');
            const downloadBtn = document.getElementById('downloadBtn');
            const settingsBtn = document.getElementById('settingsBtn');
            const pipBtn = document.getElementById('pipBtn');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            const fastForwardBtn = document.getElementById('fastForwardBtn');
            const mainPlayBtn = document.getElementById('mainPlayBtn');
            const speedBtn = document.getElementById('speedBtn');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            const favoriteBtn = document.getElementById('favoriteBtn');
            const subtitlesBtn = document.getElementById('subtitlesBtn');
            const audioBtn = document.getElementById('audioBtn');
            
            const videoProgress = document.getElementById('videoProgress');
            const videoProgressFill = document.getElementById('videoProgressFill');
            const videoTime = document.getElementById('videoTime');
            
            // Top Controls Event Listeners
            
            // Mute button
            if (muteBtn) {
                muteBtn.addEventListener('click', () => {
                    videoPlayer.muted = !videoPlayer.muted;
                    muteBtn.innerHTML = videoPlayer.muted ? '<i class="fas fa-volume-mute"></i>' : '<i class="fas fa-volume-up"></i>';
                    showNotification(videoPlayer.muted ? 'Muted' : 'Unmuted', 'info');
                });
            }
            
            // 10-second rewind
            if (rewind10Btn) {
                rewind10Btn.addEventListener('click', () => {
                    videoPlayer.currentTime = Math.max(0, videoPlayer.currentTime - 10);
                    showNotification('Rewound 10 seconds', 'info');
                });
            }
            
            // 10-second forward
            if (forward10Btn) {
                forward10Btn.addEventListener('click', () => {
                    videoPlayer.currentTime = Math.min(videoPlayer.duration, videoPlayer.currentTime + 10);
                    showNotification('Forwarded 10 seconds', 'info');
                });
            }
            
            // Download button
            if (downloadBtn) {
                downloadBtn.addEventListener('click', () => {
                    showNotification('Download feature coming soon', 'info');
                });
            }
            
            // Settings button
            if (settingsBtn) {
                settingsBtn.addEventListener('click', () => {
                    const qualityControls = document.getElementById('qualityControls');
                    if (qualityControls) {
                        qualityControls.style.display = qualityControls.style.display === 'none' ? 'flex' : 'none';
                    }
                });
            }
            
            // Picture in Picture
            if (pipBtn) {
                pipBtn.addEventListener('click', async () => {
                    try {
                        if (document.pictureInPictureElement) {
                            await document.exitPictureInPicture();
                            showNotification('Exited Picture-in-Picture', 'info');
                        } else {
                            await videoPlayer.requestPictureInPicture();
                            showNotification('Entered Picture-in-Picture', 'success');
                        }
                    } catch (error) {
                        showNotification('Picture-in-Picture not supported', 'warning');
                    }
                });
            }
            
            // Fullscreen
            if (fullscreenBtn) {
                fullscreenBtn.addEventListener('click', () => {
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                        fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i>';
                    } else {
                        videoPlayer.closest('.video-container').requestFullscreen();
                        fullscreenBtn.innerHTML = '<i class="fas fa-compress"></i>';
                    }
                });
            }
            
            // Bottom Controls Event Listeners
            
            // Fast forward
            if (fastForwardBtn) {
                fastForwardBtn.addEventListener('click', () => {
                    videoPlayer.currentTime = Math.min(videoPlayer.duration, videoPlayer.currentTime + 30);
                    showNotification('Fast forwarded 30 seconds', 'info');
                });
            }
            
            // Main play/pause button
            if (mainPlayBtn) {
                mainPlayBtn.addEventListener('click', () => {
                    if (videoPlayer.paused) {
                        videoPlayer.play();
                        mainPlayBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    } else {
                        videoPlayer.pause();
                        mainPlayBtn.innerHTML = '<i class="fas fa-play"></i>';
                    }
                });
            }
            
            // Speed control
            if (speedBtn) {
                speedBtn.addEventListener('click', () => {
                    const speeds = [0.5, 0.75, 1, 1.25, 1.5, 1.75, 2];
                    const currentSpeed = videoPlayer.playbackRate;
                    const currentIndex = speeds.indexOf(currentSpeed);
                    const nextIndex = (currentIndex + 1) % speeds.length;
                    videoPlayer.playbackRate = speeds[nextIndex];
                    showNotification(`Speed: ${speeds[nextIndex]}x`, 'info');
                });
            }
            
            // Previous episode
            if (prevBtn) {
                prevBtn.addEventListener('click', () => {
                    if (currentEpisodeIndex > 0) {
                        selectEpisode(currentEpisodeIndex - 1);
                    } else {
                        showNotification('This is the first episode', 'warning');
                    }
                });
            }
            
            // Next episode
            if (nextBtn) {
                nextBtn.addEventListener('click', () => {
                    if (currentEpisodeIndex < episodes.length - 1) {
                        selectEpisode(currentEpisodeIndex + 1);
                    } else {
                        showNotification('This is the last episode', 'warning');
                    }
                });
            }
            
            // Favorite button
            if (favoriteBtn) {
                favoriteBtn.addEventListener('click', () => {
                    if (currentAnimeInfo) {
                        // addToWatchList(currentAnimeInfo.info);
                        favoriteBtn.style.color = '#ff6b6b';
                        showNotification('Added to favorites', 'success');
                    }
                });
            }
            
            // Subtitles button
            if (subtitlesBtn) {
                subtitlesBtn.addEventListener('click', () => {
                    const subtitleControls = document.getElementById('subtitleControls');
                    if (subtitleControls) {
                        subtitleControls.style.display = subtitleControls.style.display === 'none' ? 'flex' : 'none';
                    }
                });
            }
            
            // Audio button (volume control)
            if (audioBtn) {
                audioBtn.addEventListener('click', () => {
                    const volumes = [0, 0.25, 0.5, 0.75, 1];
                    const currentVol = videoPlayer.volume;
                    const currentIndex = volumes.findIndex(vol => Math.abs(vol - currentVol) < 0.1);
                    const nextIndex = (currentIndex + 1) % volumes.length;
                    videoPlayer.volume = volumes[nextIndex];
                    showNotification(`Volume: ${Math.round(volumes[nextIndex] * 100)}%`, 'info');
                });
            }
            
            // Progress bar click (existing functionality)
            if (videoProgress) {
                videoProgress.addEventListener('click', (e) => {
                    const rect = videoProgress.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const width = rect.width;
                    const percentage = clickX / width;
                    videoPlayer.currentTime = percentage * videoPlayer.duration;
                });
            }
            
            // Update time display and progress
            videoPlayer.addEventListener('timeupdate', () => {
                if (videoPlayer.duration) {
                    // Update progress bar
                    if (videoProgressFill) {
                        const progress = (videoPlayer.currentTime / videoPlayer.duration) * 100;
                        videoProgressFill.style.width = `${progress}%`;
                    }
                    
                    // Update time displays
                    const current = formatTime(videoPlayer.currentTime);
                    const total = formatTime(videoPlayer.duration);
                    
                    if (timeDisplay) {
                        timeDisplay.textContent = `${current} / ${total}`;
                    }
                    
                    if (videoTime) {
                        videoTime.textContent = `${current} / ${total}`;
                    }
                }
            });
            
            // Update play/pause button states
            videoPlayer.addEventListener('play', () => {
                if (mainPlayBtn) mainPlayBtn.innerHTML = '<i class="fas fa-pause"></i>';
            });
            
            videoPlayer.addEventListener('pause', () => {
                if (mainPlayBtn) mainPlayBtn.innerHTML = '<i class="fas fa-play"></i>';
            });
            
            // Update volume button state
            videoPlayer.addEventListener('volumechange', () => {
                if (muteBtn) {
                    muteBtn.innerHTML = videoPlayer.muted || videoPlayer.volume === 0 ? 
                        '<i class="fas fa-volume-mute"></i>' : '<i class="fas fa-volume-up"></i>';
                }
            });
        }
        
        // Setup keyboard shortcuts for video player
        function setupKeyboardShortcuts(videoPlayer) {
            document.addEventListener('keydown', (e) => {
                // Only work when video modal is open
                const videoModal = document.getElementById('videoModal');
                if (!videoModal || videoModal.style.display === 'none') return;
                
                // Prevent default for our shortcuts
                if (['Space', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'KeyF', 'KeyM'].includes(e.code)) {
                    e.preventDefault();
                }
                
                switch (e.code) {
                    case 'Space':
                        if (videoPlayer.paused) {
                            videoPlayer.play();
                        } else {
                            videoPlayer.pause();
                        }
                        break;
                    case 'ArrowLeft':
                        videoPlayer.currentTime = Math.max(0, videoPlayer.currentTime - 10);
                        break;
                    case 'ArrowRight':
                        videoPlayer.currentTime = Math.min(videoPlayer.duration, videoPlayer.currentTime + 10);
                        break;
                    case 'ArrowUp':
                        videoPlayer.volume = Math.min(1, videoPlayer.volume + 0.1);
                        showNotification(`🔊 Volume: ${Math.round(videoPlayer.volume * 100)}%`, 'info');
                        break;
                    case 'ArrowDown':
                        videoPlayer.volume = Math.max(0, videoPlayer.volume - 0.1);
                        showNotification(`🔉 Volume: ${Math.round(videoPlayer.volume * 100)}%`, 'info');
                        break;
                    case 'KeyF':
                        if (document.fullscreenElement) {
                            document.exitFullscreen();
                        } else {
                            videoPlayer.closest('.video-container').requestFullscreen();
                        }
                        break;
                    case 'KeyM':
                        videoPlayer.muted = !videoPlayer.muted;
                        showNotification(videoPlayer.muted ? '🔇 Muted' : '🔊 Unmuted', 'info');
                        break;
                }
            });
        }
        
        // Setup mobile touch controls
        function setupMobileTouchControls(videoPlayer) {
            let tapTimeout;
            let lastTap = 0;
            
            videoPlayer.addEventListener('touchend', (e) => {
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTap;
                
                if (tapLength < 500 && tapLength > 0) {
                    // Double tap detected
                    e.preventDefault();
                    if (videoPlayer.paused) {
                        videoPlayer.play();
                    } else {
                        videoPlayer.pause();
                    }
                } else {
                    // Single tap
                    tapTimeout = setTimeout(() => {
                        // Toggle controls visibility on mobile
                        const controls = document.getElementById('videoOverlayControls');
                        if (controls) {
                            if (controls.style.opacity === '1') {
                                controls.style.opacity = '0';
                            } else {
                                controls.style.opacity = '1';
                                setTimeout(() => {
                                    controls.style.opacity = '0';
                                }, 3000);
                            }
                        }
                    }, 300);
                }
                lastTap = currentTime;
            });
        }

        // Authentication functions
        async function checkAuthStatus() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/auth/me`, {
                    credentials: 'include'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    currentUser = data.user;
                    showAuthenticatedState();
                    return true;
                } else {
                    showAuthModal();
                    return false;
                }
            } catch (error) {
                // Silently handle auth errors
                showAuthModal();
                return false;
            }
        }

        function showAuthenticatedState() {
            const authModal = document.getElementById('authModal');
            if (authModal) {
                authModal.style.display = 'none';
            }
            
            const mainContent = document.querySelector('.main');
            if (mainContent) {
                mainContent.classList.remove('content-locked');
            }
            
            console.log('Authentication state updated successfully');
        }

        function showAuthModal() {
            document.getElementById('authModal').style.display = 'flex';
            // Keep user menu visible
            document.querySelector('.main').classList.add('content-locked');
        }

        function switchToSignin() {
            isSignUpMode = false;
            const nameFields = document.getElementById('nameFields');
            const authButtonText = document.getElementById('authButtonText');
            const signinTab = document.getElementById('signinTab');
            const signupTab = document.getElementById('signupTab');
            
            nameFields.style.display = 'none';
            authButtonText.textContent = 'Sign In';
            
            signinTab.classList.add('active');
            signupTab.classList.remove('active');
            
            clearAuthMessages();
            clearForm();
        }

        function switchToSignup() {
            isSignUpMode = true;
            const nameFields = document.getElementById('nameFields');
            const authButtonText = document.getElementById('authButtonText');
            const signinTab = document.getElementById('signinTab');
            const signupTab = document.getElementById('signupTab');
            
            nameFields.style.display = 'block';
            authButtonText.textContent = 'Create Account';
            
            signupTab.classList.add('active');
            signinTab.classList.remove('active');
            
            clearAuthMessages();
            clearForm();
        }

        function clearForm() {
            document.getElementById('username').value = '';
            document.getElementById('email').value = '';
            document.getElementById('password').value = '';
        }

        function clearAuthMessages() {
            document.getElementById('authError').style.display = 'none';
            document.getElementById('authSuccess').style.display = 'none';
        }

        function showAuthError(message) {
            Swal.fire({
                icon: 'error',
                title: 'Error',
                text: message,
                confirmButtonColor: '#6366f1',
                allowOutsideClick: true,
                allowEscapeKey: true,
                confirmButtonText: 'OK'
            }).then((result) => {
                // Ensure the modal is properly closed
                if (result.isConfirmed || result.isDismissed) {
                    console.log('SweetAlert closed successfully');
                }
            });
        }

        function showAuthSuccess(message) {
            return Swal.fire({
                icon: 'success',
                title: 'Success',
                text: message,
                confirmButtonColor: '#6366f1',
                allowOutsideClick: false,
                allowEscapeKey: true,
                confirmButtonText: 'OK',
                focusConfirm: true
            });
        }

        async function handleAuth(e) {
            e.preventDefault();
            clearAuthMessages();
            
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            const submitBtn = document.getElementById('authSubmit');
            const buttonText = document.getElementById('authButtonText');
            
            if (!email || !password) {
                showAuthError('Please fill in all required fields');
                return;
            }
            
            if (isSignUpMode) {
                const username = document.getElementById('username').value;
                
                if (!username) {
                    showAuthError('Please enter a username');
                    return;
                }
            }
            
            submitBtn.disabled = true;
            buttonText.textContent = isSignUpMode ? 'Creating Account...' : 'Signing In...';
            
            try {
                const endpoint = isSignUpMode ? '/api/auth/signup' : '/api/auth/signin';
                const body = isSignUpMode ? {
                    email,
                    password,
                    firstName: document.getElementById('username').value,
                    lastName: ''
                } : { email, password };
                
                console.log('Making auth request to:', `${API_BASE_URL}${endpoint}`);
                console.log('Request body:', body);
                
                const response = await fetch(`${API_BASE_URL}${endpoint}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    credentials: 'include',
                    body: JSON.stringify(body)
                });
                
                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('Response data:', data);
                
                if (response.ok) {
                    currentUser = data.user;
                    console.log('Authentication successful, currentUser set to:', currentUser);
                    try {
                        showAuthenticatedState();
                        console.log('showAuthenticatedState completed');
                        loadContent();
                        console.log('loadContent completed');
                        updateRecentlyPlayedUI();
                        console.log('updateRecentlyPlayedUI completed');
                        showNotification('Successfully logged in!', 'success');
                    } catch (postAuthError) {
                        console.log('Error in post-auth functions:', postAuthError);
                        showNotification('Logged in successfully!', 'success');
                    }
                } else {
                    showAuthError(data.message || 'Authentication failed');
                }
            } catch (error) {
                console.log('Login error details:', error);
                showAuthError('Login failed. Please check your credentials and try again.');
            } finally {
                submitBtn.disabled = false;
                buttonText.textContent = isSignUpMode ? 'Create Account' : 'Sign In';
            }
        }

        async function logout() {
            try {
                await fetch(`${API_BASE_URL}/api/auth/logout`, {
                    method: 'POST',
                    credentials: 'include'
                });
                currentUser = null;
                showAuthModal();
                // userDropdown no longer exists
            } catch (error) {
                console.error('Logout error:', error);
            }
        }

        // Recently played functionality
        async function addToRecentlyPlayed(animeInfo, episode, progress = 0, duration = 0) {
            if (!currentUser) return;
            
            try {
                const response = await fetch(`${API_BASE_URL}/api/recently-played`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        id: animeInfo.id,
                        title: animeInfo.name,
                        poster: animeInfo.poster,
                        episode: episode,
                        progress: progress,
                        duration: duration
                    })
                });
                
                if (response.ok) {
                    updateRecentlyPlayedUI();
                }
            } catch (error) {
                console.error('Error adding to recently played:', error);
            }
        }
        
        async function getRecentlyPlayed() {
            if (!currentUser) return [];
            
            try {
                const response = await fetch(`${API_BASE_URL}/api/recently-played`, {
                    credentials: 'include'
                });
                
                if (response.ok) {
                    const result = await response.json();
                    return result.data || [];
                }
                return [];
            } catch (error) {
                console.error('Error fetching recently played:', error);
                return [];
            }
        }
        
        function updateRecentlyPlayedUI() {
            // Hide the old recently played section as we now use popup
            const section = document.getElementById('recentlyPlayedSection');
            if (section) {
                section.style.display = 'none';
            }
        }
        
        async function loadAnimeAndPlay(animeId, episode, resumeProgress = 0) {
            try {
                showNotification('Loading episode...', 'info');
                
                // Get anime info and episodes in parallel (same as openAnime)
                const [infoResponse, episodesResponse] = await Promise.all([
                    fetch(`${API_BASE_URL}/api/info?id=${animeId}`),
                    fetch(`${API_BASE_URL}/api/episodes/${animeId}`)
                ]);
                
                if (!infoResponse.ok || !episodesResponse.ok) {
                    throw new Error('Failed to fetch anime data');
                }
                
                const [infoData, episodesData] = await Promise.all([
                    infoResponse.json(),
                    episodesResponse.json()
                ]);
                
                if (infoData.error) {
                    throw new Error(infoData.message);
                }
                
                if (episodesData.error) {
                    throw new Error(episodesData.message);
                }
                
                currentAnimeInfo = infoData.anime;
                episodes = episodesData.episodes || [];
                
                // Find the episode index
                const episodeIndex = episodes.findIndex(ep => 
                    ep.number && ep.number.toString() === episode.toString()
                );
                
                if (episodeIndex !== -1) {
                    currentEpisodeIndex = episodeIndex;
                    
                    // Open video modal
                    openVideoModal();
                    
                    // Update title
                    const animeName = currentAnimeInfo?.info?.name || 
                                    currentAnimeInfo?.name || 
                                    currentAnimeInfo?.title || 
                                    'Unknown Anime';
                    document.getElementById('videoTitle').textContent = animeName;
                    
                    // Update anime info and episodes list
                    updateAnimeInfo();
                    populateEpisodesList();
                    
                    // Load the specific episode
                    const episodeId = episodes[episodeIndex]?.episodeId;
                    if (episodeId) {
                        await loadEpisode(episodeId, 'hd-1', resumeProgress);
                        updateEpisodeSelection();
                    }
                } else {
                    throw new Error(`Episode ${episode} not found in anime data`);
                }
            } catch (error) {
                console.error('Error loading anime for recently played:', error);
                showNotification('Failed to load recently played episode. Please try again.', 'error');
            }
        }


        // Auto-play next episode functionality
        let autoPlayCountdown = null;
        let autoPlayTimeout = null;
        let autoPlayEnabled = localStorage.getItem('autoPlayEnabled') === 'true'; // Default disabled

        function initializeAutoPlay() {
            const video = document.getElementById('animeVideo');
            if (!video) return;

            video.addEventListener('timeupdate', function() {
                const timeLeft = video.duration - video.currentTime;
                
                // Show countdown when 30 seconds left and episode is almost over
                if (timeLeft <= 30 && timeLeft > 0 && !video.paused && !autoPlayCountdown) {
                    showAutoPlayCountdown(Math.floor(timeLeft));
                }
            });

            video.addEventListener('ended', function() {
                if (autoPlayEnabled) {
                    startAutoPlayTimer();
                }
            });
        }

        function showAutoPlayCountdown(seconds) {
            if (!autoPlayEnabled || autoPlayCountdown) return;

            const currentEpisode = getCurrentEpisodeNumber();
            const nextEpisode = currentEpisode + 1;
            
            // Check if next episode exists
            const episodeElements = document.querySelectorAll('.episode-item');
            const nextEpisodeElement = Array.from(episodeElements).find(ep => 
                parseInt(ep.textContent.trim()) === nextEpisode
            );

            if (!nextEpisodeElement) return; // No next episode

            const countdownHtml = `
                <div class="autoplay-countdown" id="autoplayCountdown">
                    <div class="autoplay-content">
                        <div class="autoplay-header">
                            <i class="fas fa-play-circle"></i>
                            <span>Next Episode in <span id="countdownTime">${seconds}</span>s</span>
                        </div>
                        <div class="autoplay-info">
                            <span>Episode ${nextEpisode}</span>
                        </div>
                        <div class="autoplay-actions">
                            <button class="btn-secondary" onclick="cancelAutoPlay()">
                                <i class="fas fa-times"></i> Cancel
                            </button>
                            <button class="btn-primary" onclick="playNextEpisodeNow()">
                                <i class="fas fa-play"></i> Play Now
                            </button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', countdownHtml);
            autoPlayCountdown = document.getElementById('autoplayCountdown');
            
            // Update countdown every second
            const countdownInterval = setInterval(() => {
                seconds--;
                const timeElement = document.getElementById('countdownTime');
                if (timeElement) {
                    timeElement.textContent = seconds;
                }
                
                if (seconds <= 0) {
                    clearInterval(countdownInterval);
                    if (autoPlayCountdown) {
                        playNextEpisodeNow();
                    }
                }
            }, 1000);
        }

        function startAutoPlayTimer() {
            if (!autoPlayEnabled) return;

            autoPlayTimeout = setTimeout(() => {
                playNextEpisodeNow();
            }, 10000); // 10 seconds default countdown
        }

        function cancelAutoPlay() {
            if (autoPlayCountdown) {
                autoPlayCountdown.remove();
                autoPlayCountdown = null;
            }
            
            if (autoPlayTimeout) {
                clearTimeout(autoPlayTimeout);
                autoPlayTimeout = null;
            }
            
            showNotification('Auto-play cancelled', 'info');
        }

        function playNextEpisodeNow() {
            if (autoPlayCountdown) {
                autoPlayCountdown.remove();
                autoPlayCountdown = null;
            }
            
            if (autoPlayTimeout) {
                clearTimeout(autoPlayTimeout);
                autoPlayTimeout = null;
            }

            const currentEpisode = getCurrentEpisodeNumber();
            const nextEpisode = currentEpisode + 1;
            
            // Find and click next episode
            const episodeElements = document.querySelectorAll('.episode-item');
            const nextEpisodeElement = Array.from(episodeElements).find(ep => 
                parseInt(ep.textContent.trim()) === nextEpisode
            );

            if (nextEpisodeElement) {
                nextEpisodeElement.click();
                showNotification(`Playing Episode ${nextEpisode}`, 'success');
            } else {
                showNotification('No more episodes available', 'info');
            }
        }

        function getCurrentEpisodeNumber() {
            const episodeTitle = document.getElementById('animeEpisodeTitle');
            if (episodeTitle) {
                const match = episodeTitle.textContent.match(/Episode (\d+)/);
                return match ? parseInt(match[1]) : 1;
            }
            return 1;
        }

        function toggleAutoPlay() {
            autoPlayEnabled = !autoPlayEnabled;
            localStorage.setItem('autoPlayEnabled', autoPlayEnabled.toString());
            
            const icon = document.getElementById('autoPlayIcon');
            const text = document.getElementById('autoPlayText');
            
            if (autoPlayEnabled) {
                icon.className = 'fas fa-toggle-on';
                text.textContent = 'Auto-play: ON';
                showNotification('Auto-play enabled', 'success');
            } else {
                icon.className = 'fas fa-toggle-off';
                text.textContent = 'Auto-play: OFF';
                showNotification('Auto-play disabled', 'info');
                cancelAutoPlay();
            }
        }

        // Enhanced Search with Filters
        let currentSearchFilters = {
            genre: '',
            year: '',
            status: ''
        };

        function toggleSearchFilters() {
            const filters = document.getElementById('searchFilters');
            filters.classList.toggle('show');
        }

        function applySearchFilters() {
            const genreFilter = document.getElementById('genreFilter').value;
            const yearFilter = document.getElementById('yearFilter').value;
            const statusFilter = document.getElementById('statusFilter').value;
            
            currentSearchFilters = {
                genre: genreFilter,
                year: yearFilter,
                status: statusFilter
            };

            // If there's a current search query, re-run the search with filters
            const searchInput = document.getElementById('searchInput');
            if (searchInput.value.trim()) {
                performSearch(searchInput.value.trim());
            }

            showNotification('Filters applied', 'info');
        }

        function clearSearchFilters() {
            document.getElementById('genreFilter').value = '';
            document.getElementById('yearFilter').value = '';
            document.getElementById('statusFilter').value = '';
            
            currentSearchFilters = {
                genre: '',
                year: '',
                status: ''
            };

            // Re-run current search without filters
            const searchInput = document.getElementById('searchInput');
            if (searchInput.value.trim()) {
                performSearch(searchInput.value.trim());
            }

            showNotification('Filters cleared', 'info');
        }

        function filterAnimeResults(animeList) {
            if (!animeList || animeList.length === 0) return animeList;

            return animeList.filter(anime => {
                // Filter by genre (if specified)
                if (currentSearchFilters.genre) {
                    const animeGenres = anime.genres || [];
                    const hasGenre = animeGenres.some(genre => 
                        genre.toLowerCase().includes(currentSearchFilters.genre.toLowerCase())
                    );
                    if (!hasGenre) return false;
                }

                // Filter by year (if specified)
                if (currentSearchFilters.year) {
                    const animeYear = anime.releaseDate || anime.releasedDate || '';
                    if (!animeYear.includes(currentSearchFilters.year)) return false;
                }

                // Filter by status (if specified)
                if (currentSearchFilters.status) {
                    const animeStatus = (anime.status || '').toLowerCase();
                    const filterStatus = currentSearchFilters.status.toLowerCase();
                    
                    if (filterStatus === 'completed' && !animeStatus.includes('completed')) return false;
                    if (filterStatus === 'ongoing' && !animeStatus.includes('ongoing')) return false;
                    if (filterStatus === 'upcoming' && !animeStatus.includes('upcoming')) return false;
                }

                return true;
            });
        }

        async function performSearch(query) {
            if (!query || query.length < 2) {
                clearSearchResults();
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/search?q=${encodeURIComponent(query)}`);
                if (!response.ok) {
                    throw new Error(`Search failed with status ${response.status}`);
                }
                const data = await response.json();
                
                if (data && data.animes) {
                    // Apply filters to search results
                    const filteredResults = filterAnimeResults(data.animes);
                    displaySearchResults(filteredResults, query);
                } else {
                    displaySearchResults([], query);
                }
            } catch (error) {
                console.error('Search error:', error);
                showNotification('Search failed. Please try again.', 'error');
            }
        }

        // User Statistics and Profile
        async function calculateUserStats() {
            if (!currentUser) return null;

            try {
                const [recentlyPlayed, favorites] = await Promise.all([
                    getRecentlyPlayed(),
                    getFavorites()
                ]);

                // Calculate total watch time (approximate based on progress)
                let totalWatchTime = 0;
                let episodesWatched = 0;
                let completedEpisodes = 0;

                recentlyPlayed.forEach(item => {
                    if (item.duration && item.progress) {
                        totalWatchTime += (item.progress / 100) * (item.duration / 60); // Convert to minutes
                        episodesWatched++;
                        if (item.progress >= 90) { // Consider 90%+ as completed
                            completedEpisodes++;
                        }
                    }
                });

                // Extract genres from favorites for genre preference analysis
                const genreCount = {};
                favorites.forEach(anime => {
                    if (anime.genres) {
                        anime.genres.forEach(genre => {
                            genreCount[genre] = (genreCount[genre] || 0) + 1;
                        });
                    }
                });

                const topGenres = Object.entries(genreCount)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 3)
                    .map(([genre]) => genre);

                return {
                    totalWatchTime: Math.round(totalWatchTime),
                    episodesWatched,
                    completedEpisodes,
                    favoritesCount: favorites.length,
                    topGenres,
                    joinDate: currentUser.createdAt ? new Date(currentUser.createdAt).toLocaleDateString() : 'Unknown',
                    completionRate: episodesWatched > 0 ? Math.round((completedEpisodes / episodesWatched) * 100) : 0
                };
            } catch (error) {
                console.error('Error calculating stats:', error);
                return null;
            }
        }

        // Sound Effects System
        const soundEffects = {
            click: new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBjiH1/LLfSkGJ3TH8N+Jy'),
            success: new Audio('data:audio/wav;base64,UklGRu4CAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YcoCAAC4uLi4QkJCQkJCQkJCQkJCuLi4uLi4uEJCQkJCQkJCQkJCQkK4uLi4uLi4QkJCQkJCQkJCQkJCQri4uLi4uLhCQkJCQkJCQkJCQkJCuLi4uLi4uEJCQkJCQkJCQkJCQkK4uLi4uLi4QkJCQkJCQkJCQkJCQri4uLi4uLhCQkJCQkJCQkJCQkJCuLi4uLi4uEJCQkJCQkJCQkJCQkK4uLi4uLi4'),
            error: new Audio('data:audio/wav;base64,UklGRu4CAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YcoCAABCQkJCQkJCuLi4uLi4uLi4uLi4uLi4uLi4QkJCQkJCQkJCQkJCQri4uLi4uLi4uLi4uLi4uLi4uEJCQkJCQkJCQkJCQkK4uLi4uLi4uLi4uLi4uLi4uEJCQkJCQkJCQkJCQkK4uLi4uLi4uLi4uLi4uLi4uEJCQkJCQkJCQkJCQkK4uLi4uLi4uLi4uLi4uLi4uEJCQkJCQkJCQkJCQkK4uLi4uLi4'),
            notification: new Audio('data:audio/wav;base64,UklGRu4CAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YcoCAAC4uLhCQkJCQkJCuLi4uLi4uLi4uLi4uEJCQkJCQkJCQkJCQri4uLi4uLi4uLi4uLhCQkJCQkJCQkJCQkK4uLi4uLi4uLi4uLhCQkJCQkJCQkJCQkK4uLi4uLi4uLi4uLhCQkJCQkJCQkJCQkK4uLi4uLi4uLi4uLhCQkJCQkJCQkJCQkK4uLi4uLi4uLi4uLhCQkJCQkJCQkJCQkK4uLi4uLi4')
        };

        let soundEnabled = localStorage.getItem('soundEnabled') !== 'false';

        function playSound(type) {
            if (soundEnabled && soundEffects[type]) {
                try {
                    soundEffects[type].volume = 0.1;
                    soundEffects[type].play().catch((error) => {
                        console.debug('Audio play failed (normal in some browsers):', error.message);
                        // Silent fail if audio can't play
                    });
                } catch (error) {
                    console.debug('Sound effect error:', error.message);
                    // Silent fail for sound effects
                }
            }
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            localStorage.setItem('soundEnabled', soundEnabled.toString());
            
            // Update sound icon
            const soundIcon = document.getElementById('soundIcon');
            if (soundIcon) {
                soundIcon.className = soundEnabled ? 'fas fa-volume-up' : 'fas fa-volume-mute';
            }
            
            if (soundEnabled) {
                showNotification('🔊 Sound effects enabled', 'success');
                playSound('success');
            } else {
                showNotification('🔇 Sound effects disabled', 'info');
            }
        }

        // Loading States Management
        function showLoadingState(element, type = 'card') {
            if (!element) return;
            
            element.classList.add('loading-skeleton');
            
            if (type === 'card') {
                element.innerHTML = `
                    <div class="card-skeleton loading-skeleton"></div>
                    <div class="text-skeleton loading-skeleton"></div>
                    <div class="text-skeleton short loading-skeleton"></div>
                `;
            }
        }

        function hideLoadingState(element) {
            if (!element) return;
            element.classList.remove('loading-skeleton');
        }

        // Simple SweetAlert2 notification
        function showNotification(message, type = 'info') {
            const swalType = type === 'success' ? 'success' : type === 'error' ? 'error' : type === 'warning' ? 'warning' : 'info';
            
            Swal.fire({
                icon: swalType,
                text: message,
                toast: true,
                position: 'top-end',
                showConfirmButton: false,
                timer: 3000,
                timerProgressBar: true,
                background: '#1f2937',
                color: '#f9fafb'
            });
        }
        
        // Simple popup functions
        function showTrendingPopup() {
            Swal.fire({
                title: 'Trending Anime',
                text: 'Loading trending anime...',
                icon: 'info',
                confirmButtonColor: '#6366f1',
                background: '#1f2937',
                color: '#f9fafb'
            });
        }
        
        function showPopularPopup() {
            Swal.fire({
                title: 'Popular Anime',
                text: 'Loading popular anime...',
                icon: 'info',
                confirmButtonColor: '#6366f1',
                background: '#1f2937',
                color: '#f9fafb'
            });
        }
        
        function showFavoritesPopup() {
            Swal.fire({
                title: 'My Favorites',
                text: 'No favorite anime found. Start adding some!',
                icon: 'info',
                confirmButtonColor: '#6366f1',
                background: '#1f2937',
                color: '#f9fafb'
            });
        }
        
        function showRecentlyPlayedPopup() {
            Swal.fire({
                title: 'Recently Watched',
                text: 'No recently watched anime found.',
                icon: 'info',
                confirmButtonColor: '#6366f1',
                background: '#1f2937',
                color: '#f9fafb'
            });
        }

        // Keyboard shortcuts help
        function showKeyboardShortcuts() {
            const hints = document.createElement('div');
            hints.className = 'keyboard-shortcuts-hint';
            hints.innerHTML = `
                <strong>Keyboard Shortcuts:</strong><br>
                <span class="shortcut-key">/</span> Search<br>
                <span class="shortcut-key">H</span> History<br>
                <span class="shortcut-key">L</span> Favorites<br>
                <span class="shortcut-key">T</span> Toggle Theme<br>
                <span class="shortcut-key">Esc</span> Close<br>
                <span class="shortcut-key">Space</span> Play/Pause<br>
                <span class="shortcut-key">←/→</span> Seek ±10s
            `;
            
            document.body.appendChild(hints);
            
            setTimeout(() => hints.classList.add('show'), 100);
            
            setTimeout(() => {
                hints.classList.remove('show');
                setTimeout(() => {
                    if (hints.parentNode) {
                        hints.parentNode.removeChild(hints);
                    }
                }, 300);
            }, 5000);
        }

        async function showUserStats() {
            // Show loading skeleton first
            showCustomPopup({
                title: '📊 My Statistics',
                content: '<div class="loading-skeleton" style="height: 300px; border-radius: 15px;"></div>',
                buttons: [{
                    text: 'Loading...',
                    class: 'btn-secondary',
                    disabled: true
                }]
            });

            const stats = await calculateUserStats();
            
            if (!stats) {
                showNotification('Unable to load statistics', 'error');
                closeCustomPopup();
                return;
            }

            const hoursWatched = Math.floor(stats.totalWatchTime / 60);
            const minutesWatched = stats.totalWatchTime % 60;
            
            const htmlContent = `
                <div class="user-stats">
                    <div class="user-stats-header">
                        <div class="user-avatar-large">
                            ${currentUser.firstName ? currentUser.firstName.charAt(0).toUpperCase() : 'U'}
                        </div>
                        <div class="user-info">
                            <h3>${currentUser.firstName || 'User'} ${currentUser.lastName || ''}</h3>
                            <p>Member since ${stats.joinDate}</p>
                        </div>
                    </div>
                    
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-icon">
                                <i class="fas fa-clock"></i>
                            </div>
                            <div class="stat-info">
                                <div class="stat-number">${hoursWatched}h ${minutesWatched}m</div>
                                <div class="stat-label">Total Watch Time</div>
                            </div>
                        </div>
                        
                        <div class="stat-card">
                            <div class="stat-icon">
                                <i class="fas fa-play-circle"></i>
                            </div>
                            <div class="stat-info">
                                <div class="stat-number">${stats.episodesWatched}</div>
                                <div class="stat-label">Episodes Watched</div>
                            </div>
                        </div>
                        
                        <div class="stat-card">
                            <div class="stat-icon">
                                <i class="fas fa-check-circle"></i>
                            </div>
                            <div class="stat-info">
                                <div class="stat-number">${stats.completedEpisodes}</div>
                                <div class="stat-label">Episodes Completed</div>
                            </div>
                        </div>
                        
                        <div class="stat-card">
                            <div class="stat-icon">
                                <i class="fas fa-heart"></i>
                            </div>
                            <div class="stat-info">
                                <div class="stat-number">${stats.favoritesCount}</div>
                                <div class="stat-label">Favorites</div>
                            </div>
                        </div>
                        
                        <div class="stat-card">
                            <div class="stat-icon">
                                <i class="fas fa-percentage"></i>
                            </div>
                            <div class="stat-info">
                                <div class="stat-number">${stats.completionRate}%</div>
                                <div class="stat-label">Completion Rate</div>
                            </div>
                        </div>
                        
                        <div class="stat-card full-width">
                            <div class="stat-icon">
                                <i class="fas fa-tags"></i>
                            </div>
                            <div class="stat-info">
                                <div class="stat-number">${stats.topGenres.length > 0 ? stats.topGenres.join(', ') : 'No data'}</div>
                                <div class="stat-label">Top Genres</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="stats-actions">
                        <button class="btn-primary" onclick="showFavoritesPopup(); closeCustomPopup();">
                            <i class="fas fa-heart"></i> View Favorites
                        </button>
                        <button class="btn-secondary" onclick="showRecentlyPlayedPopup(); closeCustomPopup();">
                            <i class="fas fa-history"></i> Recently Played
                        </button>
                    </div>
                </div>
            `;
            
            showCustomPopup({
                title: '📊 My Statistics',
                content: htmlContent,
                buttons: [{
                    text: 'Close',
                    class: 'btn-secondary',
                    action: () => closeCustomPopup()
                }],
                size: 'large'
            });
        }

        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            const body = document.body;
            body.setAttribute('data-theme', savedTheme);
        }

        // Performance optimization variables
        let searchDebounceTimeout = null;
        let isOnline = navigator.onLine;
        let loadingStates = new Set();

        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
            initializeTheme();
            setupEventListeners();
            initializePerformanceOptimizations();
            setupKeyboardShortcuts();
            initializeOfflineDetection();
            
            checkAuthStatus().then(isAuthenticated => {
                if (isAuthenticated) {
                    loadContent();
                    updateRecentlyPlayedUI();
                    updateFavoriteIcons();
                }
            }).catch(error => {
                // Silently handle auth initialization errors
                // Continue with app initialization even if auth fails
            });
            
            // Initialize auto-play controls
            const autoPlayIcon = document.getElementById('autoPlayIcon');
            const autoPlayText = document.getElementById('autoPlayText');
            if (autoPlayIcon && autoPlayText) {
                if (autoPlayEnabled) {
                    autoPlayIcon.className = 'fas fa-toggle-on';
                    autoPlayText.textContent = 'Auto-play: ON';
                } else {
                    autoPlayIcon.className = 'fas fa-toggle-off';
                    autoPlayText.textContent = 'Auto-play: OFF';
                }
            }
        });

        // Performance Optimizations
        function initializePerformanceOptimizations() {
            // Lazy loading for images
            const imageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        if (img.dataset.src) {
                            img.src = img.dataset.src;
                            img.removeAttribute('data-src');
                            observer.unobserve(img);
                        }
                    }
                });
            }, {
                rootMargin: '50px'
            });

            // Apply lazy loading to all future images
            window.lazyLoadImage = function(img) {
                imageObserver.observe(img);
            };

            // Optimize animations with will-change
            const cards = document.querySelectorAll('.insane-card');
            cards.forEach(card => {
                card.style.willChange = 'transform';
            });

            // Debounced search
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.addEventListener('input', debounceSearch);
            }
        }

        function debounceSearch(event) {
            clearTimeout(searchDebounceTimeout);
            const query = event.target.value.trim();
            
            if (query.length === 0) {
                clearSearchResults();
                return;
            }
            
            if (query.length < 2) return;
            
            searchDebounceTimeout = setTimeout(() => {
                performSearch(query);
            }, 300); // 300ms delay to reduce API calls
        }

        // Keyboard Shortcuts
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', function(e) {
                // Don't trigger shortcuts when typing in inputs
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                
                switch(e.key) {
                    case '/':
                        e.preventDefault();
                        document.getElementById('searchInput')?.focus();
                        break;
                    case 'Escape':
                        closeVideoModal();
                        closeCustomPopup();
                        document.getElementById('searchFilters')?.classList.remove('show');
                        break;
                    case 'f':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            document.getElementById('searchInput')?.focus();
                        }
                        break;
                    case 'h':
                        if (!e.ctrlKey && !e.metaKey) {
                            e.preventDefault();
                            showRecentlyPlayedPopup();
                        }
                        break;
                    case 'l':
                        if (!e.ctrlKey && !e.metaKey) {
                            e.preventDefault();
                            showFavoritesPopup();
                        }
                        break;
                    case 't':
                        // Theme toggle removed
                        break;
                    case ' ':
                        const video = document.getElementById('animeVideo');
                        if (video && document.getElementById('videoModal').style.display === 'flex') {
                            e.preventDefault();
                            try {
                                if (video.paused) {
                                    video.play().catch(error => console.debug('Video play failed:', error.message));
                                } else {
                                    video.pause();
                                }
                            } catch (error) {
                                console.debug('Video control error:', error.message);
                            }
                        }
                        break;
                    case 'ArrowLeft':
                        const videoLeft = document.getElementById('animeVideo');
                        if (videoLeft && document.getElementById('videoModal').style.display === 'flex') {
                            e.preventDefault();
                            videoLeft.currentTime = Math.max(0, videoLeft.currentTime - 10);
                        }
                        break;
                    case 'ArrowRight':
                        const videoRight = document.getElementById('animeVideo');
                        if (videoRight && document.getElementById('videoModal').style.display === 'flex') {
                            e.preventDefault();
                            videoRight.currentTime = Math.min(videoRight.duration, videoRight.currentTime + 10);
                        }
                        break;
                }
            });
        }

        // Offline Detection
        function initializeOfflineDetection() {
            window.addEventListener('online', function() {
                isOnline = true;
                showNotification('Connection restored! 🎉', 'success');
                // Retry failed requests
                retryFailedRequests();
            });

            window.addEventListener('offline', function() {
                isOnline = false;
                showNotification('You are offline 📡', 'warning');
            });
        }

        let failedRequests = [];

        function addFailedRequest(requestFn) {
            if (!isOnline) {
                failedRequests.push(requestFn);
            }
        }

        function retryFailedRequests() {
            if (failedRequests.length > 0) {
                showNotification(`Retrying ${failedRequests.length} failed requests...`, 'info');
                const requests = [...failedRequests];
                failedRequests = [];
                
                requests.forEach(requestFn => {
                    try {
                        requestFn();
                    } catch (error) {
                        console.error('Failed to retry request:', error);
                    }
                });
            }
        }

        function initializeApp() {
            console.log('AniHUB Enhanced initialized');
            
            // Header scroll effect
            window.addEventListener('scroll', function() {
                const header = document.getElementById('header');
                if (window.scrollY > 50) {
                    header.style.background = 'rgba(15, 15, 35, 0.98)';
                } else {
                    header.style.background = 'rgba(15, 15, 35, 0.95)';
                }
            });
        }

        function setupEventListeners() {
            // Authentication form
            document.getElementById('authForm').addEventListener('submit', handleAuth);
            
            // Mobile menu toggle
            const mobileMenu = document.getElementById('mobileMenu');
            const navLinks = document.querySelector('.nav-links');
            const menuIcon = mobileMenu.querySelector('i');
            
            mobileMenu.addEventListener('click', () => {
                navLinks.classList.toggle('show');
                
                // Animate menu icon
                if (navLinks.classList.contains('show')) {
                    menuIcon.classList.remove('fa-bars');
                    menuIcon.classList.add('fa-times');
                    mobileMenu.style.transform = 'rotate(180deg)';
                } else {
                    menuIcon.classList.remove('fa-times');
                    menuIcon.classList.add('fa-bars');
                    mobileMenu.style.transform = 'rotate(0deg)';
                }
            });
            
            // Close menu when clicking outside
            document.addEventListener('click', (e) => {
                if (!navLinks.contains(e.target) && !mobileMenu.contains(e.target)) {
                    navLinks.classList.remove('show');
                    menuIcon.classList.remove('fa-times');
                    menuIcon.classList.add('fa-bars');
                    mobileMenu.style.transform = 'rotate(0deg)';
                }
            });
            
            // Close mobile menu when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.nav') && !e.target.closest('.mobile-menu')) {
                    document.querySelector('.nav-links').classList.remove('show');
                }
            });
            
            // Search functionality
            const searchInput = document.getElementById('searchInput');
            
            searchInput.addEventListener('input', handleSearch);
            
            // Close search results when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.hero-search')) {
                    document.getElementById('searchResults').style.display = 'none';
                }
            });

            // Quality selection
            const qualitySelect = document.getElementById('qualitySelect');
            if (qualitySelect) {
                qualitySelect.addEventListener('change', function() {
                    const selectedQuality = this.value;
                    console.log('Quality changed to:', selectedQuality);
                    switchVideoQuality(selectedQuality);
                });
            }

            // Subtitle selection
            const subtitleSelect = document.getElementById('subtitleSelect');
            if (subtitleSelect) {
                subtitleSelect.addEventListener('change', function() {
                    const videoPlayer = document.getElementById('videoPlayer');
                    const selectedTrack = this.value;
                    
                    // Remove existing text tracks
                    Array.from(videoPlayer.textTracks).forEach(track => {
                        track.mode = 'disabled';
                    });
                    
                    if (selectedTrack) {
                        const trackElement = videoPlayer.querySelector(`track[src="${selectedTrack}"]`);
                        if (trackElement && trackElement.track) {
                            trackElement.track.mode = 'showing';
                        }
                    }
                });
            }

            // Navigation
            document.querySelectorAll('.nav-link').forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    document.querySelectorAll('.nav-link').forEach(l => l.classList.remove('active'));
                    this.classList.add('active');
                    
                    const href = this.getAttribute('href');
                    if (href && href !== '#' && href.length > 1) {
                        const target = href.substring(1);
                        if (target === 'home') {
                            window.scrollTo({ top: 0, behavior: 'smooth' });
                        }
                    } else if (href === '#home' || href === '#') {
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                    }
                });
            });

            // Server controls
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('server-btn')) {
                    if (currentAnimeId && episodes.length > 0) {
                        const episodeId = episodes[currentEpisodeIndex]?.episodeId;
                        if (episodeId) {
                            currentServer = e.target.dataset.server;
                            loadEpisode(episodeId, currentServer);
                        }
                    }
                }
            });

            // Episode controls
            document.getElementById('prevEpisode').addEventListener('click', function() {
                if (currentEpisodeIndex > 0) {
                    currentEpisodeIndex--;
                    const episodeId = episodes[currentEpisodeIndex]?.episodeId;
                    if (episodeId) {
                        const activeServer = document.querySelector('.server-btn.active')?.dataset.server || 'hd-1';
                        loadEpisode(episodeId, activeServer);
                        updateEpisodeSelection();
                    }
                }
            });

            document.getElementById('nextEpisode').addEventListener('click', function() {
                if (currentEpisodeIndex < episodes.length - 1) {
                    currentEpisodeIndex++;
                    const episodeId = episodes[currentEpisodeIndex]?.episodeId;
                    if (episodeId) {
                        const activeServer = document.querySelector('.server-btn.active')?.dataset.server || 'hd-1';
                        loadEpisode(episodeId, activeServer);
                        updateEpisodeSelection();
                    }
                }
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    closeVideoModal();
                }
            });
        }

        function handleSearch(e) {
            if (!currentUser) {
                showAuthModal();
                return;
            }
            
            const query = e.target.value.trim();
            const searchResults = document.getElementById('searchResults');
            
            if (searchTimeout) {
                clearTimeout(searchTimeout);
            }
            
            if (query.length < 2) {
                searchResults.style.display = 'none';
                return;
            }
            
            searchTimeout = setTimeout(() => {
                performSearch(query);
            }, 300);
        }

        async function performSearch(query) {
            // Close any open popups first to prevent overlay conflicts
            closeCustomPopup();
            
            const searchResults = document.getElementById('searchResults');
            searchResults.innerHTML = '<div class="loading-state"><div class="loading-spinner"></div> Searching...</div>';
            searchResults.style.display = 'block';
            
            try {
                const response = await fetch(`${API_BASE_URL}/api/search?q=${encodeURIComponent(query)}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.message);
                }
                
                displaySearchResults(data.animes || []);
            } catch (error) {
                console.error('Search error:', error);
                searchResults.innerHTML = '<div class="error-state"><i class="fas fa-exclamation-triangle"></i><p>Search unavailable</p></div>';
            }
        }

        function displaySearchResults(results) {
            const searchResults = document.getElementById('searchResults');
            
            if (results.length === 0) {
                searchResults.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--text-muted);">No results found</div>';
                return;
            }
            
            searchResults.innerHTML = results.slice(0, 8).map(anime => `
                <div class="search-result" data-anime-id="${anime.id}" data-anime-name="${anime.name.replace(/"/g, '&quot;')}" data-poster="${anime.poster || ''}" data-release="${anime.releaseDate || 'N/A'}" data-type="${anime.type || 'TV'}">
                    <img src="${anime.poster || 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNTYiIHZpZXdCb3g9IjAgMCA0MCA1NiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjQwIiBoZWlnaHQ9IjU2IiBmaWxsPSIjMTYyMTNlIi8+Cjx0ZXh0IHg9IjIwIiB5PSIzMCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjEwIiBmaWxsPSIjNmI3MjgwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj5ObyBJbWFnZTwvdGV4dD4KPC9zdmc+'}" 
                         alt="${anime.name.replace(/"/g, '&quot;')}" class="search-result-image"
                         onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNTYiIHZpZXdCb3g9IjAgMCA0MCA1NiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjQwIiBoZWlnaHQ9IjU2IiBmaWxsPSIjMTYyMTNlIi8+Cjx0ZXh0IHg9IjIwIiB5PSIzMCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjEwIiBmaWxsPSIjNmI3MjgwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj5ObyBJbWFnZTwvdGV4dD4KPC9zdmc+'">
                    <div class="search-result-info">
                        <h4>${anime.name}</h4>
                        <p>${anime.releaseDate || 'N/A'} • ${anime.type || 'TV'}</p>
                    </div>
                </div>
            `).join('');
            
            // Add event listeners to search results
            setTimeout(() => {
                const resultElements = searchResults.querySelectorAll('.search-result');
                resultElements.forEach(result => {
                    result.addEventListener('click', function() {
                        const animeId = this.dataset.animeId;
                        
                        // Go directly to video player instead of showing popup
                        document.getElementById('searchResults').style.display = 'none';
                        openAnime(animeId);
                    });
                });
            }, 50);
        }

        async function loadContent() {
            if (!currentUser) {
                return;
            }
            // Content is now loaded on-demand in popups
            console.log('Content loading is now handled by custom popups');
        }

        async function loadTrending() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/home`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.message);
                }
                
                const trending = data.trendingAnimes || [];
                return trending;
            } catch (error) {
                console.error('Error loading trending:', error);
                return [];
            }
        }

        async function loadPopular() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/home`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.message);
                }
                
                const popular = data.mostPopularAnimes || [];
                return popular;
            } catch (error) {
                console.error('Error loading popular:', error);
                return [];
            }
        }

        async function loadRecent() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/home`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.message);
                }
                
                const recent = data.latestEpisodeAnimes || [];
                return recent;
            } catch (error) {
                console.error('Error loading recent:', error);
                return [];
            }
        }

        function displayAnimeGrid(gridId, animeList) {
            const grid = document.getElementById(gridId);
            if (!grid) return;
            
            if (!animeList || animeList.length === 0) {
                grid.innerHTML = '<div class="error-state"><p>No anime available</p></div>';
                return;
            }
            
            grid.innerHTML = animeList.map(anime => createAnimeCard(anime)).join('');
        }

        function createAnimeCard(anime) {
            const status = anime.type || 'TV';
            const rating = '8.5'; // Default rating
            const fallbackImage = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQwIiBoZWlnaHQ9IjMyMCIgdmlld0JveD0iMCAwIDI0MCAzMjAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIyNDAiIGhlaWdodD0iMzIwIiBmaWxsPSIjMTYyMTNlIi8+Cjx0ZXh0IHg9IjEyMCIgeT0iMTcwIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMTQiIGZpbGw9IiM2YjcyODAiIHRleHQtYW5jaG9yPSJtaWRkbGUiPk5vIEltYWdlPC90ZXh0Pgo8L3N2Zz4=";
            
            return `
                <div class="anime-card" onclick="openAnime('${anime.id}')">
                    <div class="anime-poster">
                        <img src="${anime.poster || fallbackImage}" 
                             alt="${anime.name}" loading="lazy"
                             onerror="this.src='${fallbackImage}'">
                        <div class="anime-status">${status}</div>
                        <div class="anime-rating">
                            <i class="fas fa-star"></i> ${rating}
                        </div>
                        <div class="play-overlay">
                            <button class="play-button">
                                <i class="fas fa-play"></i>
                            </button>
                        </div>
                    </div>
                    <div class="anime-info">
                        <h3 class="anime-title">${anime.name}</h3>
                        <div class="anime-meta">
                            <span>${anime.releaseDate || 'N/A'}</span>
                            <span>${anime.type || 'TV'}</span>
                        </div>
                        <div class="anime-genres">
                            ${(anime.genres || ['Action', 'Adventure']).slice(0, 3).map(genre => 
                                `<span class="genre-tag">${genre}</span>`
                            ).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        async function openAnime(animeId) {
            currentAnimeId = animeId;
            
            try {
                showNotification('Loading anime...', 'info');
                
                // Get anime info and episodes in parallel
                const [infoResponse, episodesResponse] = await Promise.all([
                    fetch(`${API_BASE_URL}/api/info?id=${animeId}`),
                    fetch(`${API_BASE_URL}/api/episodes/${animeId}`)
                ]);
                
                if (!infoResponse.ok || !episodesResponse.ok) {
                    throw new Error('Failed to fetch anime data');
                }
                
                const [infoData, episodesData] = await Promise.all([
                    infoResponse.json(),
                    episodesResponse.json()
                ]);
                
                if (infoData.error) {
                    throw new Error(infoData.message);
                }
                
                if (episodesData.error) {
                    throw new Error(episodesData.message);
                }
                
                currentAnimeInfo = infoData.anime;
                episodes = episodesData.episodes || [];
                currentEpisodeIndex = 0;
                
                console.log('Loaded anime info:', currentAnimeInfo);
                console.log('Anime name:', currentAnimeInfo?.name);
                console.log('Full info data structure:', infoData);
                
                if (episodes.length > 0) {
                    openVideoModal();
                    // Extract anime name from the correct data structure
                    const animeName = currentAnimeInfo?.info?.name || 
                                    currentAnimeInfo?.name || 
                                    currentAnimeInfo?.title || 
                                    infoData?.anime?.info?.name ||
                                    infoData?.name || 
                                    infoData?.title ||
                                    'Unknown Anime';
                    
                    console.log('Setting title to:', animeName);
                    document.getElementById('videoTitle').textContent = animeName;
                    updateAnimeInfo();
                    populateEpisodesList();
                    await loadEpisode(episodes[0].episodeId, 'hd-1');
                } else {
                    throw new Error('No episodes available');
                }
                
            } catch (error) {
                console.error('Error opening anime:', error);
                showNotification('Unable to load anime. Please try again later.', 'error');
            }
        }

        function updateAnimeInfo() {
            if (!currentAnimeInfo) {
                console.log('No currentAnimeInfo available');
                return;
            }
            
            console.log('Updating anime info:', currentAnimeInfo?.info?.name || currentAnimeInfo?.name);
            
            // Update main info - use correct data structure
            const titleElement = document.getElementById('videoTitle');
            if (titleElement) {
                const animeName = currentAnimeInfo?.info?.name || 
                                currentAnimeInfo?.name || 
                                currentAnimeInfo?.title || 
                                'Unknown Anime';
                titleElement.textContent = animeName;
                console.log('Updated title to:', animeName);
            }
            
            const episodesCountElement = document.getElementById('episodesCount');
            if (episodesCountElement) {
                episodesCountElement.textContent = `${episodes.length} episodes`;
            }
        }

        function populateEpisodesList() {
            const episodesList = document.getElementById('episodesList');
            
            if (!episodes.length) {
                episodesList.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--text-muted);">No episodes available</div>';
                return;
            }
            
            episodesList.innerHTML = episodes.map((episode, index) => `
                <div class="episode-item ${index === currentEpisodeIndex ? 'active' : ''}" 
                     onclick="selectEpisode(${index})">
                    <div class="episode-number">Episode ${episode.number || index + 1}</div>
                    <div class="episode-title">${episode.title || `Episode ${index + 1}`}</div>
                </div>
            `).join('');
        }

        function updateEpisodeSelection() {
            // Update episode info
            const currentEpisode = episodes[currentEpisodeIndex];
            if (currentEpisode) {
                document.getElementById('videoEpisode').textContent = `Episode ${currentEpisode.number || currentEpisodeIndex + 1}`;
            }
            
            // Update episode list selection
            document.querySelectorAll('.episode-item').forEach((item, index) => {
                if (index === currentEpisodeIndex) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
            
            // Update button states
            document.getElementById('prevEpisode').disabled = currentEpisodeIndex === 0;
            document.getElementById('nextEpisode').disabled = currentEpisodeIndex === episodes.length - 1;
        }

        function selectEpisode(index) {
            if (index >= 0 && index < episodes.length && index !== currentEpisodeIndex) {
                currentEpisodeIndex = index;
                const episodeId = episodes[currentEpisodeIndex]?.episodeId;
                if (episodeId) {
                    const activeServer = document.querySelector('.server-btn.active')?.dataset.server || 'hd-1';
                    loadEpisode(episodeId, activeServer);
                    updateEpisodeSelection();
                }
            }
        }

        function openVideoModal() {
            const modal = document.getElementById('videoModal');
            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
            
            // Set initial title if we have anime info
            const animeName = currentAnimeInfo?.info?.name || currentAnimeInfo?.name;
            if (currentAnimeInfo && animeName) {
                const titleElement = document.getElementById('videoTitle');
                if (titleElement) {
                    titleElement.textContent = animeName;
                    console.log('Set title in openVideoModal:', animeName);
                }
            }
        }

        async function loadEpisode(episodeId, server = 'hd-1', resumeProgress = 0) {
            bufferingIndicator = bufferingIndicator || document.getElementById('bufferingIndicator');
            const videoPlayer = document.getElementById('videoPlayer');
            const progressBar = null; // Progress bar removed
            
            // Show loading with enhanced animation
            bufferingIndicator.style.display = 'block';
            if (progressBar) progressBar.style.width = '0%';
            
            // Clear any existing timeouts
            if (window.videoLoadTimeout) {
                clearTimeout(window.videoLoadTimeout);
            }
            
            // Clean up previous HLS instance
            if (currentHls) {
                currentHls.destroy();
                currentHls = null;
            }
            
            // Clear previous video state
            videoPlayer.pause();
            videoPlayer.src = '';
            videoPlayer.load();

            try {
                console.log(`Loading episode ${episodeId} from ${server} server...`);
                updateLoadingStatus(`🔄 Connecting to ${server.toUpperCase()} server...`);
                
                // Smooth progress animation
                animateProgress(progressBar, 15, 500);
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    controller.abort();
                    updateLoadingStatus('⚠️ Connection timeout, trying next server...');
                }, 12000); // Reduced timeout for faster fallback
                
                const response = await fetch(`${API_BASE_URL}/api/episode-srcs?id=${episodeId}&server=${server}`, {
                    signal: controller.signal,
                    headers: {
                        'Accept': 'application/json',
                        'Cache-Control': 'no-cache'
                    }
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`Server responded with ${response.status}`);
                }
                
                updateLoadingStatus('📊 Processing video sources...');
                animateProgress(progressBar, 40, 300);
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.message || 'Failed to load episode sources');
                }
                
                if (data.sources && data.sources.length > 0) {
                    // Store all video sources for quality selection
                    currentVideoSources = data.sources;
                    currentServer = server;
                    
                    updateLoadingStatus('⚙️ Setting up quality options...');
                    animateProgress(progressBar, 60, 200);
                    
                    // Setup quality options
                    setupQualityOptions(data.sources);
                    
                    // Find the best source (prefer highest quality M3U8)
                    const hlsSources = data.sources.filter(s => s.isM3U8);
                    const source = hlsSources.length > 0 ? 
                        hlsSources.sort((a, b) => parseInt(b.quality?.replace('p', '') || 0) - parseInt(a.quality?.replace('p', '') || 0))[0] : 
                        data.sources[0];
                    
                    updateLoadingStatus('🎬 Preparing video player...');
                    animateProgress(progressBar, 80, 200);
                    
                    // Use proxy for video streaming to fix CORS issues
                    const proxyUrl = `${API_BASE_URL}/api/proxy-video?url=${encodeURIComponent(source.url)}`;
                    
                    updateLoadingStatus('▶️ Loading video file...');
                    
                    // Enhanced player setup with better error handling
                    await setupEnhancedVideoPlayer(proxyUrl, videoPlayer, progressBar, data.headers, resumeProgress, source.isM3U8);
                    
                    // Setup subtitles if available
                    setupSubtitles(data.tracks || []);
                    
                    console.log(`Episode loaded successfully from ${server}`);
                    updateEpisodeSelection();
                    
                    // Add to recently played without progress initially  
                    if (currentAnimeInfo && episodes[currentEpisodeIndex]) {
                        const episodeNumber = episodes[currentEpisodeIndex].number || currentEpisodeIndex + 1;
                        addToRecentlyPlayed(currentAnimeInfo.info, episodeNumber, 0, 0);
                    }
                    
                    // Update active server button with visual feedback
                    document.querySelectorAll('.server-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.server === server);
                    });
                    
                    // Final progress completion
                    animateProgress(progressBar, 100, 200);
                    setTimeout(() => {
                        bufferingIndicator.style.display = 'none';
                        showNotification(`✅ Now playing from ${server.toUpperCase()} server`, 'success');
                    }, 400);
                    
                } else {
                    throw new Error('No video sources available from server');
                }
            } catch (error) {
                console.error(`Error loading from ${server}:`, error);
                
                // Try next server automatically with better UX
                const servers = ['hd-1', 'megacloud', 'hd-2'];
                const currentIndex = servers.indexOf(server);
                const nextServer = servers[currentIndex + 1];
                
                if (nextServer && !error.message.includes('abort')) {
                    console.log(`Automatically trying ${nextServer} server...`);
                    updateLoadingStatus(`⚠️ ${server.toUpperCase()} failed, switching to ${nextServer.toUpperCase()}...`);
                    showNotification(`Switching to ${nextServer.toUpperCase()} server...`, 'warning');
                    
                    // Smooth transition to next server
                    setTimeout(() => {
                        loadEpisode(episodeId, nextServer, resumeProgress);
                    }, 1500);
                } else {
                    bufferingIndicator.style.display = 'none';
                    showNotification(`❌ All servers failed. Please try again later.`, 'error');
                }
            }
        }

        async function testVideoSource(url) {
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('Source test timeout'));
                }, 5000);
                
                if (url.includes('.m3u8')) {
                    // For HLS streams, just resolve as we'll handle errors in HLS setup
                    clearTimeout(timeout);
                    resolve();
                } else {
                    // For direct video, test with a HEAD request
                    fetch(url, { method: 'HEAD', mode: 'no-cors' })
                        .then(() => {
                            clearTimeout(timeout);
                            resolve();
                        })
                        .catch(() => {
                            clearTimeout(timeout);
                            resolve(); // Even if HEAD fails, try anyway
                        });
                }
            });
        }

        // Enhanced video player setup with better error handling and performance
        async function setupEnhancedVideoPlayer(sourceUrl, videoPlayer, progressBar, headers = {}, resumeProgress = 0, isHLS = false) {
            console.log('Setting up enhanced video player with internet monitoring');
            
            // Clean up any existing video
            videoPlayer.pause();
            videoPlayer.src = '';
            videoPlayer.load();
            
            // Set video properties
            videoPlayer.crossOrigin = 'anonymous';
            videoPlayer.preload = 'metadata';
            
            // Get UI elements
            const speedMeter = document.getElementById('speedMeter');
            bufferingIndicator = bufferingIndicator || document.getElementById('bufferingIndicator');
            
            // Setup quality options - check if we have HLS with multiple qualities
            if (sourceUrl.includes('.m3u8')) {
                fetch(sourceUrl)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Failed to fetch M3U8: ${response.status}`);
                        }
                        return response.text();
                    })
                    .then(m3u8Content => {
                        const qualities = parseM3U8Qualities(m3u8Content, sourceUrl);
                        if (qualities.length > 1) {
                            setupQualityOptions(qualities);
                            console.log('Found', qualities.length, 'quality levels');
                        } else {
                            setupQualityOptions([{ url: sourceUrl, quality: 'Auto', isM3U8: true }]);
                        }
                    })
                    .catch(err => {
                        console.error('Failed to parse M3U8:', err);
                        setupQualityOptions([{ url: sourceUrl, quality: 'Auto', isM3U8: true }]);
                    });
            } else {
                setupQualityOptions([{ url: sourceUrl, quality: 'Auto', isM3U8: false }]);
            }
            
            // Set video source with improved error handling
            try {
                videoPlayer.src = sourceUrl;
                videoPlayer.load();
                
                // Add promise-based error handling for load operation
                const loadPromise = new Promise((resolve, reject) => {
                    const onLoad = () => {
                        videoPlayer.removeEventListener('loadeddata', onLoad);
                        videoPlayer.removeEventListener('error', onError);
                        resolve();
                    };
                    const onError = (e) => {
                        videoPlayer.removeEventListener('loadeddata', onLoad);
                        videoPlayer.removeEventListener('error', onError);
                        reject(e);
                    };
                    videoPlayer.addEventListener('loadeddata', onLoad);
                    videoPlayer.addEventListener('error', onError);
                });
                
                // Set a timeout for the load operation
                Promise.race([
                    loadPromise,
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Load timeout')), 15000))
                ]).catch(error => {
                    console.error('Video load promise error:', error);
                    // Don't show error to user immediately, let other error handlers deal with it
                });
                
            } catch (error) {
                console.error('Error setting video source:', error);
                updateLoadingStatus('Failed to set video source');
                return;
            }
            
            // Internet speed monitoring
            let startTime = Date.now();
            let bytesLoaded = 0;
            
            const startSpeedMonitoring = () => {
                speedMeter.style.display = 'block';
                const speedValue = document.getElementById('speedValue');
                const bufferInfo = document.getElementById('bufferInfo');
                const qualityInfo = document.getElementById('qualityInfo');
                const pingInfo = document.getElementById('pingInfo');
                
                if (speedValue) speedValue.textContent = 'Measuring...';
                if (bufferInfo) bufferInfo.textContent = 'Buffer: 0%';
                if (qualityInfo) qualityInfo.textContent = 'Quality: Auto';
                if (pingInfo) pingInfo.textContent = 'Ping: -ms';
                
                let pingStartTime = Date.now();
                
                speedMeterInterval = setInterval(() => {
                    if (videoPlayer.buffered.length > 0) {
                        const currentTime = Date.now();
                        const duration = videoPlayer.duration || 0;
                        const bufferedEnd = videoPlayer.buffered.end(videoPlayer.buffered.length - 1);
                        
                        // Fix buffer percentage calculation to prevent overflow
                        let bufferedPercent = 0;
                        if (duration > 0 && bufferedEnd >= 0) {
                            bufferedPercent = Math.min(100, Math.round((bufferedEnd / duration) * 100));
                        }
                        
                        // Estimate download speed based on buffered content
                        const timeDiff = (currentTime - startTime) / 1000;
                        if (timeDiff > 1) {
                            const estimatedBytes = bufferedEnd * 1000000; // Rough estimate
                            const speed = estimatedBytes / timeDiff;
                            const speedText = formatSpeed(speed);
                            if (speedValue) speedValue.textContent = speedText;
                        }
                        
                        // Update buffer info
                        if (bufferInfo) bufferInfo.textContent = `Buffer: ${bufferedPercent}%`;
                        
                        // Update quality info from current video
                        const currentQuality = getCurrentQuality();
                        if (qualityInfo) qualityInfo.textContent = `Quality: ${currentQuality}`;
                        
                        // Simulate ping (in real app you'd measure actual latency)
                        const ping = Math.round(Math.random() * 50 + 20);
                        if (pingInfo) pingInfo.textContent = `Ping: ${ping}ms`;
                        
                    } else {
                        if (speedValue) speedValue.textContent = '0 KB/s';
                        if (bufferInfo) bufferInfo.textContent = 'Buffer: 0%';
                    }
                }, 1000);
            };
            
            const stopSpeedMonitoring = () => {
                if (speedMeterInterval) {
                    clearInterval(speedMeterInterval);
                    speedMeterInterval = null;
                }
                // Keep speed meter visible, just show 0
                const speedValue = document.getElementById('speedValue');
                const bufferInfo = document.getElementById('bufferInfo');
                const qualityInfo = document.getElementById('qualityInfo');
                const pingInfo = document.getElementById('pingInfo');
                
                if (speedValue) speedValue.textContent = '0 KB/s';
                if (bufferInfo) bufferInfo.textContent = 'Buffer: 0%';
                if (qualityInfo) qualityInfo.textContent = 'Quality: Auto';
                if (pingInfo) pingInfo.textContent = 'Ping: -ms';
            };
            
            // Initialize speed meter immediately
            speedMeter.style.display = 'block';
            const speedValue = document.getElementById('speedValue');
            const bufferInfo = document.getElementById('bufferInfo');
            const qualityInfo = document.getElementById('qualityInfo');
            const pingInfo = document.getElementById('pingInfo');
            
            if (speedValue) speedValue.textContent = '0 KB/s';
            if (bufferInfo) bufferInfo.textContent = 'Buffer: 0%';
            if (qualityInfo) qualityInfo.textContent = 'Quality: Auto';
            if (pingInfo) pingInfo.textContent = 'Ping: -ms';
            
            // Handle loading events
            const handleLoadStart = () => {
                if (progressBar) progressBar.style.width = '90%';
                updateLoadingStatus('Loading video...');
                startSpeedMonitoring();
                // Show loading dots when video starts loading
                bufferingIndicator.style.display = 'block';
            };
            
            const handleLoadedData = () => {
                if (progressBar) progressBar.style.width = '100%';
                updateLoadingStatus('Video ready!');
                
                // Resume from saved progress if provided
                if (resumeProgress > 0 && videoPlayer.duration > resumeProgress) {
                    videoPlayer.currentTime = resumeProgress;
                    console.log(`Resuming from ${formatTime(resumeProgress)}`);
                    showNotification(`Resuming from ${formatTime(resumeProgress)}`, 'info');
                }
                
                // Auto-play when video data is loaded
                tryAutoPlay(videoPlayer);
                
                setTimeout(() => {
                    bufferingIndicator.style.display = 'none';
                }, 300);
                cleanup();
            };
            
            const handleCanPlay = () => {
                if (progressBar) progressBar.style.width = '100%';
                bufferingIndicator.style.display = 'none'; // Hide buffering when video can play
                
                // Resume from saved progress if provided (fallback if handleLoadedData didn't work)
                if (resumeProgress > 0 && videoPlayer.duration > resumeProgress && videoPlayer.currentTime < 5) {
                    videoPlayer.currentTime = resumeProgress;
                    console.log(`Resuming from ${formatTime(resumeProgress)} (canplay)`);
                }
                
                // Auto-play when video can play (fallback)
                if (videoPlayer.paused) {
                    tryAutoPlay(videoPlayer);
                }
                
                setTimeout(() => {
                    bufferingIndicator.style.display = 'none';
                }, 300);
                cleanup();
            };
            
            const handleWaiting = () => {
                // Show buffering only if video is actually stalled and not playing smoothly
                if (!videoPlayer.paused && videoPlayer.readyState < 3) {
                    bufferingIndicator.style.display = 'block';
                    console.log('Video buffering...');
                }
            };
            
            const handleCanPlayThrough = () => {
                // Hide buffering when video can play through without stalling
                bufferingIndicator.style.display = 'none';
                if (videoPlayer.readyState >= 3 && videoPlayer.currentTime > 0) {
                    bufferingIndicator.style.display = 'none';
                }
            };
            
            const handleSeeked = () => {
                bufferingIndicator.style.display = 'none';
            };
            
            const handleSeeking = () => {
                // Don't show buffering during manual seeking
                bufferingIndicator.style.display = 'none';
            };
            
            const handlePlaying = () => {
                // Hide buffering immediately when video starts playing
                bufferingIndicator.style.display = 'none';
                if (videoPlayer.readyState >= 3 && videoPlayer.currentTime > 0) {
                    bufferingIndicator.style.display = 'none';
                }
            };
            
            const handleError = (e) => {
                console.error('Direct video player error:', e);
                updateLoadingStatus('Trying different approach...');
                
                // Try without crossOrigin attribute as fallback
                if (videoPlayer.crossOrigin) {
                    console.log('Retrying without crossOrigin');
                    videoPlayer.crossOrigin = null;
                    videoPlayer.src = sourceUrl;
                    videoPlayer.load();
                    return;
                }
                
                cleanup();
                // Video loading already handled by bufferingIndicator
                showNotification('Video failed to load. Please try a different server.', 'error');
            };
            
            const cleanup = () => {
                videoPlayer.removeEventListener('loadstart', handleLoadStart);
                videoPlayer.removeEventListener('loadeddata', handleLoadedData);
                videoPlayer.removeEventListener('canplay', handleCanPlay);
                videoPlayer.removeEventListener('waiting', handleWaiting);
                videoPlayer.removeEventListener('canplaythrough', handleCanPlayThrough);
                videoPlayer.removeEventListener('playing', handlePlaying);
                videoPlayer.removeEventListener('error', handleError);
                stopSpeedMonitoring();
            };
            
            // Add event listeners
            videoPlayer.addEventListener('loadstart', handleLoadStart);
            videoPlayer.addEventListener('loadeddata', handleLoadedData);
            videoPlayer.addEventListener('canplay', handleCanPlay);
            videoPlayer.addEventListener('waiting', handleWaiting);
            videoPlayer.addEventListener('canplaythrough', handleCanPlayThrough);
            videoPlayer.addEventListener('playing', handlePlaying);
            videoPlayer.addEventListener('error', handleError);
            
            // Add progress tracking
            setupVideoProgressTracking(videoPlayer);
            
            // Setup custom video controls
            setupCustomVideoControls(videoPlayer);
            
            // Setup video health monitoring
            setupVideoHealthMonitoring(videoPlayer);
            
            // Enhanced timeout with better UX
            window.videoLoadTimeout = setTimeout(() => {
                if (bufferingIndicator.style.display !== 'none') {
                    console.log('Video loading timeout');
                    cleanup();
                    bufferingIndicator.style.display = 'none';
                    showNotification('⏱️ Video loading timeout. Trying next server...', 'warning');
                }
            }, 20000); // Increased timeout for better experience
        }

        // Video health monitoring system to detect playback issues
        function setupVideoHealthMonitoring(videoPlayer) {
            bufferingIndicator = bufferingIndicator || document.getElementById('bufferingIndicator');
            let healthCheckInterval;
            let lastCurrentTime = 0;
            let stallCount = 0;
            let isPlaying = false;
            
            const startHealthMonitoring = () => {
                console.log('Starting video health monitoring...');
                
                healthCheckInterval = setInterval(() => {
                    try {
                    const currentTime = videoPlayer.currentTime;
                    const duration = videoPlayer.duration;
                    const readyState = videoPlayer.readyState;
                    const networkState = videoPlayer.networkState;
                    
                    // Check if video is supposed to be playing but isn't progressing
                    if (!videoPlayer.paused && !videoPlayer.seeking) {
                        isPlaying = true;
                        
                        // If current time hasn't changed and we're not at the end
                        if (currentTime === lastCurrentTime && currentTime < duration - 1 && readyState < 4) {
                            stallCount++;
                            
                            // Only show loading if truly stalled for 3+ seconds AND readyState is low
                            if (stallCount >= 3 && readyState < 3) {
                                console.log('Video stalled detected, showing loading dots');
                                bufferingIndicator.style.display = 'block';
                            }
                        } else {
                            stallCount = 0;
                            // Hide loading if video is progressing or has good readyState
                            if (readyState >= 3 && (currentTime > lastCurrentTime || readyState >= 4)) {
                                bufferingIndicator.style.display = 'none';
                            }
                        }
                    } else {
                        isPlaying = false;
                        stallCount = 0;
                        // Hide loading when paused
                        if (videoPlayer.paused) {
                            bufferingIndicator.style.display = 'none';
                        }
                    }
                    
                    // Check for network issues
                    if (networkState === HTMLMediaElement.NETWORK_NO_SOURCE) {
                        console.log('Network issue detected: No source');
                        bufferingIndicator.style.display = 'block';
                    }
                    
                    // Only show loading if video appears truly stuck at beginning
                    if (currentTime === 0 && readyState < 3 && !videoPlayer.paused && stallCount >= 3) {
                        bufferingIndicator.style.display = 'block';
                    }
                    
                    lastCurrentTime = currentTime;
                    } catch (error) {
                        console.error('Video health monitoring error:', error);
                        // Continue monitoring even if there's an error
                    }
                }, 1000); // Check every second
            };
            
            const stopHealthMonitoring = () => {
                if (healthCheckInterval) {
                    clearInterval(healthCheckInterval);
                    healthCheckInterval = null;
                }
            };
            
            // Start monitoring when video starts playing
            videoPlayer.addEventListener('play', () => {
                startHealthMonitoring();
                // Hide loading immediately when play starts
                setTimeout(() => {
                    if (!videoPlayer.paused && videoPlayer.readyState >= 3) {
                        bufferingIndicator.style.display = 'none';
                    }
                }, 500);
            });
            videoPlayer.addEventListener('pause', stopHealthMonitoring);
            videoPlayer.addEventListener('ended', stopHealthMonitoring);
            
            // Hide loading when video is playing smoothly
            videoPlayer.addEventListener('playing', () => {
                // Video loading already handled by bufferingIndicator
            });
            
            // Hide loading when video can play through
            videoPlayer.addEventListener('canplaythrough', () => {
                // Video loading already handled by bufferingIndicator
            });
            
            // Clean up on error
            videoPlayer.addEventListener('error', stopHealthMonitoring);
            
            // Store reference for cleanup
            videoPlayer._healthMonitoringCleanup = () => {
                stopHealthMonitoring();
                videoPlayer.removeEventListener('play', startHealthMonitoring);
                videoPlayer.removeEventListener('pause', stopHealthMonitoring);
                videoPlayer.removeEventListener('ended', stopHealthMonitoring);
                videoPlayer.removeEventListener('error', stopHealthMonitoring);
            };
        }

        function setupDirectPlayer(sourceUrl, videoPlayer, progressBar, headers = {}) {
            bufferingIndicator = bufferingIndicator || document.getElementById('bufferingIndicator');
            console.log('Setting up direct video player with URL:', sourceUrl);
            
            // Clean up any existing video
            videoPlayer.pause();
            videoPlayer.src = '';
            videoPlayer.load();
            
            // Set video properties
            videoPlayer.crossOrigin = 'anonymous';
            videoPlayer.preload = 'metadata';
            
            // Set video source with proper handling
            try {
                videoPlayer.src = sourceUrl;
                videoPlayer.load();
            } catch (error) {
                console.error('Error setting video source:', error);
                updateLoadingStatus('Failed to set video source');
                return;
            }
            
            // Handle loading events
            const handleLoadStart = () => {
                if (progressBar) progressBar.style.width = '90%';
                updateLoadingStatus('Loading video...');
            };
            
            const handleLoadedData = () => {
                if (progressBar) progressBar.style.width = '100%';
                updateLoadingStatus('Video ready!');
                setTimeout(() => {
                    bufferingIndicator.style.display = 'none';
                }, 300);
                cleanup();
            };
            
            const handleCanPlay = () => {
                if (progressBar) progressBar.style.width = '100%';
                setTimeout(() => {
                    bufferingIndicator.style.display = 'none';
                }, 300);
                cleanup();
            };
            
            const handleError = (e) => {
                console.error('Direct video player error:', e);
                updateLoadingStatus('Trying different approach...');
                
                // Try without crossOrigin attribute as fallback
                if (videoPlayer.crossOrigin) {
                    console.log('Retrying without crossOrigin');
                    videoPlayer.crossOrigin = null;
                    videoPlayer.src = sourceUrl;
                    videoPlayer.load();
                    return;
                }
                
                cleanup();
                // Video loading already handled by bufferingIndicator
                showNotification('Video failed to load. Please try a different server.', 'error');
            };
            
            const cleanup = () => {
                videoPlayer.removeEventListener('loadstart', handleLoadStart);
                videoPlayer.removeEventListener('loadeddata', handleLoadedData);
                videoPlayer.removeEventListener('canplay', handleCanPlay);
                videoPlayer.removeEventListener('canplaythrough', handleCanPlayThrough);
                videoPlayer.removeEventListener('playing', handlePlaying);
                videoPlayer.removeEventListener('waiting', handleWaiting);
                videoPlayer.removeEventListener('seeking', handleSeeking);
                videoPlayer.removeEventListener('seeked', handleSeeked);
                videoPlayer.removeEventListener('error', handleError);
            };
            
            // Add event listeners
            videoPlayer.addEventListener('loadstart', handleLoadStart);
            videoPlayer.addEventListener('loadeddata', handleLoadedData);
            videoPlayer.addEventListener('canplay', handleCanPlay);
            videoPlayer.addEventListener('canplaythrough', handleCanPlayThrough);
            videoPlayer.addEventListener('playing', handlePlaying);
            videoPlayer.addEventListener('waiting', handleWaiting);
            videoPlayer.addEventListener('seeking', handleSeeking);
            videoPlayer.addEventListener('seeked', handleSeeked);
            videoPlayer.addEventListener('error', handleError);
            
            // Add progress tracking
            setupVideoProgressTracking(videoPlayer);
            
            // Setup custom video controls
            setupCustomVideoControls(videoPlayer);
            
            // Set timeout fallback
            setTimeout(() => {
                if (bufferingIndicator.style.display !== 'none') {
                    console.log('Video loading timeout');
                    cleanup();
                    bufferingIndicator.style.display = 'none';
                    showNotification('Video loading timeout. Please try a different server.', 'error');
                }
            }, 10000);
        }

        function setupSubtitles(tracks) {
            const subtitleControls = document.getElementById('subtitleControls');
            const subtitleSelect = document.getElementById('subtitleSelect');
            const videoPlayer = document.getElementById('videoPlayer');
            
            // Clear existing options and tracks
            subtitleSelect.innerHTML = '<option value="">No Subtitles</option>';
            
            // Remove existing subtitle tracks
            const existingTracks = videoPlayer.querySelectorAll('track');
            existingTracks.forEach(track => track.remove());
            
            // Filter subtitle tracks (exclude thumbnails)
            const subtitleTracks = tracks.filter(track => 
                track.url && track.lang && track.lang !== 'thumbnails'
            );
            
            if (subtitleTracks.length > 0) {
                subtitleTracks.forEach((track, index) => {
                    // Add option to select
                    const option = document.createElement('option');
                    option.value = index.toString();
                    option.textContent = track.lang;
                    subtitleSelect.appendChild(option);
                    
                    // Add track element to video
                    const trackElement = document.createElement('track');
                    trackElement.kind = 'subtitles';
                    trackElement.label = track.lang;
                    trackElement.srclang = track.lang.toLowerCase().substring(0, 2);
                    trackElement.src = track.url;
                    trackElement.default = false;
                    videoPlayer.appendChild(trackElement);
                });
                
                // Add subtitle change event handler
                subtitleSelect.addEventListener('change', function() {
                    const selectedValue = this.value;
                    const textTracks = videoPlayer.textTracks;
                    
                    // Hide all tracks
                    for (let i = 0; i < textTracks.length; i++) {
                        textTracks[i].mode = 'hidden';
                    }
                    
                    // Show selected track
                    if (selectedValue !== '' && textTracks[selectedValue]) {
                        textTracks[selectedValue].mode = 'showing';
                        showNotification(`Subtitles: ${subtitleTracks[selectedValue].lang}`, 'success');
                    } else {
                        showNotification('Subtitles disabled', 'info');
                    }
                });
                
                subtitleControls.style.display = 'flex';
            } else {
                subtitleControls.style.display = 'none';
            }
        }

        function setupHLSPlayerWithQuality(sourceUrl, videoPlayer, progressBar, headers = {}) {
            bufferingIndicator = bufferingIndicator || document.getElementById('bufferingIndicator');
            currentHls = new Hls({
                debug: false,
                enableWorker: false,
                manifestLoadingMaxRetry: 1,
                levelLoadingMaxRetry: 1,
                fragLoadingMaxRetry: 1,
                manifestLoadingRetryDelay: 2000,
                levelLoadingRetryDelay: 2000,
                fragLoadingRetryDelay: 2000,
                manifestLoadingTimeOut: 10000,
                levelLoadingTimeOut: 10000,
                fragLoadingTimeOut: 10000,
                lowLatencyMode: false,
                startLevel: -1,
                maxBufferLength: 30,
                maxMaxBufferLength: 60,
                xhrSetup: function(xhr, url) {
                    // Add headers if provided
                    if (headers.Referer) {
                        xhr.setRequestHeader('Referer', headers.Referer);
                    }
                    xhr.setRequestHeader('Origin', window.location.origin);
                    xhr.setRequestHeader('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36');
                    xhr.timeout = 10000;
                }
            });

            let loadingProgress = 80;
            let hasData = false;
            let errorCount = 0;

            currentHls.on(Hls.Events.MANIFEST_PARSED, () => {
                loadingProgress = 90;
                if (progressBar) progressBar.style.width = loadingProgress + '%';
                console.log('HLS manifest loaded');
                hasData = true;
                
                // Setup quality levels from HLS manifest
                setupHLSQualityLevels();
                
                // Auto-play when HLS manifest is ready
                tryAutoPlay(videoPlayer);
            });

            currentHls.on(Hls.Events.FRAG_LOADED, () => {
                loadingProgress = Math.min(loadingProgress + 2, 95);
                if (progressBar) progressBar.style.width = loadingProgress + '%';
                hasData = true;
            });

            videoPlayer.addEventListener('loadeddata', () => {
                if (progressBar) progressBar.style.width = '100%';
                setTimeout(() => {
                    bufferingIndicator.style.display = 'none';
                }, 300);
                hasData = true;
            });

            videoPlayer.addEventListener('canplay', () => {
                if (!hasData) {
                    if (progressBar) progressBar.style.width = '100%';
                    setTimeout(() => {
                        bufferingIndicator.style.display = 'none';
                    }, 300);
                    hasData = true;
                }
            });

            currentHls.on(Hls.Events.ERROR, (event, data) => {
                console.error('HLS Error:', data);
                errorCount++;
                
                if (data.fatal || errorCount >= 2) {
                    console.log('HLS error limit reached, cleaning up');
                    
                    // Clean up current HLS
                    if (currentHls) {
                        currentHls.destroy();
                        currentHls = null;
                    }
                    
                    bufferingIndicator.style.display = 'none';
                    showNotification('Video failed to load. Please try a different server.', 'error');
                }
            });

            // Timeout fallback
            setTimeout(() => {
                if (!hasData && bufferingIndicator && bufferingIndicator.style.display !== 'none') {
                    console.log('HLS loading timeout');
                    if (currentHls) {
                        currentHls.destroy();
                        currentHls = null;
                    }
                    bufferingIndicator.style.display = 'none';
                    showNotification('Video loading timeout. Please try a different server.', 'error');
                }
            }, 10000);

            currentHls.loadSource(sourceUrl);
            currentHls.attachMedia(videoPlayer);
        }

        function setupHLSPlayer(sourceUrl, videoPlayer, progressBar, headers = {}) {
            // Fallback for backwards compatibility
            setupHLSPlayerWithQuality(sourceUrl, videoPlayer, progressBar, headers);
        }

        function parseM3U8Qualities(m3u8Content, baseUrl) {
            const qualities = [];
            const lines = m3u8Content.split('\n');
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line.startsWith('#EXT-X-STREAM-INF:')) {
                    const nextLine = lines[i + 1]?.trim();
                    if (nextLine && !nextLine.startsWith('#')) {
                        // Extract resolution and bandwidth
                        const resolutionMatch = line.match(/RESOLUTION=(\d+)x(\d+)/);
                        const bandwidthMatch = line.match(/BANDWIDTH=(\d+)/);
                        
                        let quality = 'Unknown';
                        if (resolutionMatch) {
                            const height = resolutionMatch[2];
                            quality = `${height}p`;
                            if (bandwidthMatch) {
                                const bandwidth = Math.round(parseInt(bandwidthMatch[1]) / 1000);
                                quality += ` (${bandwidth}k)`;
                            }
                        }
                        
                        // Build full URL
                        let qualityUrl = nextLine;
                        if (!qualityUrl.startsWith('http')) {
                            const baseUrlParts = baseUrl.split('/');
                            baseUrlParts.pop();
                            qualityUrl = baseUrlParts.join('/') + '/' + qualityUrl;
                        }
                        
                        qualities.push({
                            url: qualityUrl,
                            quality: quality,
                            isM3U8: true,
                            height: resolutionMatch ? parseInt(resolutionMatch[2]) : 0
                        });
                    }
                }
            }
            
            // Sort by quality (highest first)
            qualities.sort((a, b) => b.height - a.height);
            
            return qualities;
        }

        function setupQualityOptions(sources) {
            const qualityControls = document.getElementById('qualityControls');
            const qualitySelect = document.getElementById('qualitySelect');
            
            if (!qualityControls || !qualitySelect) return;
            
            // Clear existing options
            qualitySelect.innerHTML = '';
            
            // Always add Auto option
            const autoOption = document.createElement('option');
            autoOption.value = 'auto';
            autoOption.textContent = 'Auto';
            qualitySelect.appendChild(autoOption);
            
            if (sources && sources.length > 1) {
                // Filter sources by quality if available
                const qualityLevels = [];
                
                sources.forEach((source, index) => {
                    let qualityLabel = `Quality ${index + 1}`;
                    
                    // Try to extract quality from URL or metadata
                    if (source.quality) {
                        qualityLabel = source.quality;
                    } else if (source.url) {
                        // Look for common quality indicators in URL
                        if (source.url.includes('1080') || source.url.includes('1920')) {
                            qualityLabel = '1080p';
                        } else if (source.url.includes('720') || source.url.includes('1280')) {
                            qualityLabel = '720p';
                        } else if (source.url.includes('480') || source.url.includes('854')) {
                            qualityLabel = '480p';
                        } else if (source.url.includes('360') || source.url.includes('640')) {
                            qualityLabel = '360p';
                        }
                    }
                    
                    qualityLevels.push({
                        index: index,
                        label: qualityLabel,
                        source: source
                    });
                });
                
                // Sort by quality (higher first)
                qualityLevels.sort((a, b) => {
                    const aNum = parseInt(a.label) || 0;
                    const bNum = parseInt(b.label) || 0;
                    return bNum - aNum;
                });
                
                // Add options to select
                qualityLevels.forEach(level => {
                    const option = document.createElement('option');
                    option.value = level.index;
                    option.textContent = level.label;
                    qualitySelect.appendChild(option);
                });
                
                qualityControls.style.display = 'flex';
                currentVideoSources = sources;
                console.log('Quality selector shown with', qualityLevels.length, 'options');
            } else {
                qualityControls.style.display = 'none';
                currentVideoSources = sources || [];
            }
        }

        function setupHLSQualityLevels() {
            if (!currentHls || !currentHls.levels) return;
            
            const qualitySelect = document.getElementById('qualitySelect');
            const qualityControls = document.getElementById('qualityControls');
            
            // Clear existing options except auto
            qualitySelect.innerHTML = '<option value="auto">Auto</option>';
            
            if (currentHls.levels.length > 1) {
                // Add quality levels from HLS manifest
                currentHls.levels.forEach((level, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    
                    // Create quality label
                    let qualityLabel = `${level.height}p`;
                    if (level.bitrate) {
                        qualityLabel += ` (${Math.round(level.bitrate / 1000)}k)`;
                    }
                    
                    option.textContent = qualityLabel;
                    qualitySelect.appendChild(option);
                });
                
                qualityControls.style.display = 'flex';
            }
        }

        function switchVideoQuality(quality) {
            const videoPlayer = document.getElementById('videoPlayer');
            const currentTime = videoPlayer.currentTime;
            const isPaused = videoPlayer.paused;
            
            if (quality === 'auto') {
                showNotification('Quality set to Auto', 'success');
            } else if (currentVideoSources && currentVideoSources.length > 1) {
                // Switch to different source for non-HLS videos
                const sourceIndex = parseInt(quality);
                if (sourceIndex >= 0 && sourceIndex < currentVideoSources.length) {
                    const newSource = currentVideoSources[sourceIndex];
                    const proxyUrl = `${API_BASE_URL}/api/proxy-video?url=${encodeURIComponent(newSource.url)}`;
                    
                    // Store current playback position
                    videoPlayer.src = proxyUrl;
                    videoPlayer.load();
                    
                    // Restore playback position when ready
                    const restorePosition = () => {
                        if (currentTime > 0) {
                            videoPlayer.currentTime = currentTime;
                        }
                        if (!isPaused) {
                            // Use auto-play function for consistent behavior
                            tryAutoPlay(videoPlayer);
                        }
                        videoPlayer.removeEventListener('loadeddata', restorePosition);
                    };
                    
                    videoPlayer.addEventListener('loadeddata', restorePosition);
                    
                    // Extract quality label for notification
                    let qualityLabel = `Quality ${sourceIndex + 1}`;
                    if (newSource.quality) {
                        qualityLabel = newSource.quality;
                    }
                    
                    showNotification(`Quality changed to ${qualityLabel}`, 'success');
                }
            } else {
                showNotification('Quality switching not available for this video', 'info');
            }
        }

        function formatSpeed(bytesPerSecond) {
            if (bytesPerSecond < 1024) {
                return Math.round(bytesPerSecond) + ' B/s';
            } else if (bytesPerSecond < 1024 * 1024) {
                return Math.round(bytesPerSecond / 1024) + ' KB/s';
            } else {
                return (bytesPerSecond / (1024 * 1024)).toFixed(1) + ' MB/s';
            }
        }

        function closeVideoModal() {
            const modal = document.getElementById('videoModal');
            const videoPlayer = document.getElementById('videoPlayer');
            const speedMeter = document.getElementById('speedMeter');
            bufferingIndicator = bufferingIndicator || document.getElementById('bufferingIndicator');
            
            // Save progress before closing
            if (videoPlayer.currentTime > 0 && currentAnimeInfo && episodes[currentEpisodeIndex]) {
                const progress = Math.floor(videoPlayer.currentTime);
                const duration = Math.floor(videoPlayer.duration || 0);
                const episodeNumber = episodes[currentEpisodeIndex].number || currentEpisodeIndex + 1;
                saveVideoProgress(currentAnimeInfo.info, episodeNumber, progress, duration);
            }
            
            // Clear progress tracking
            if (progressTrackingInterval) {
                clearInterval(progressTrackingInterval);
                progressTrackingInterval = null;
            }
            
            modal.style.display = 'none';
            document.body.style.overflow = 'auto';
            
            // Stop video and clean up
            videoPlayer.pause();
            videoPlayer.src = '';
            
            if (currentHls) {
                currentHls.destroy();
                currentHls = null;
            }
            
            // Clean up speed monitoring
            if (speedMeterInterval) {
                clearInterval(speedMeterInterval);
                speedMeterInterval = null;
            }
            
            // Clean up health monitoring
            if (videoPlayer._healthMonitoringCleanup) {
                videoPlayer._healthMonitoringCleanup();
                videoPlayer._healthMonitoringCleanup = null;
            }
            
            // Hide buffering indicator only, keep speed meter visible
            if (bufferingIndicator) bufferingIndicator.style.display = 'none';
            if (speedMeter) {
                const speedValue = document.getElementById('speedValue');
                const bufferInfo = document.getElementById('bufferInfo');
                const qualityInfo = document.getElementById('qualityInfo');
                const pingInfo = document.getElementById('pingInfo');
                
                if (speedValue) speedValue.textContent = '0 KB/s';
                if (bufferInfo) bufferInfo.textContent = 'Buffer: 0%';
                if (qualityInfo) qualityInfo.textContent = 'Quality: Auto';
                if (pingInfo) pingInfo.textContent = 'Ping: -ms';
                speedMeter.style.display = 'block';
            }
            
            // Reset state
            currentAnimeId = null;
            currentAnimeInfo = null;
            currentEpisodeIndex = 0;
            episodes = [];
            currentVideoSources = [];
            currentServer = 'hd-1';
            
            // Reset server selection
            document.querySelectorAll('.server-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector('.server-btn[data-server="hd-1"]')?.classList.add('active');
            
            // Hide quality controls and subtitle controls
            const qualityControls = document.getElementById('qualityControls');
            const subtitleControls = document.getElementById('subtitleControls');
            if (qualityControls) {
                qualityControls.style.display = 'none';
            }
            if (subtitleControls) {
                subtitleControls.style.display = 'none';
            }
            
            // Clear subtitle tracks
            const existingTracks = videoPlayer.querySelectorAll('track');
            existingTracks.forEach(track => track.remove());
        }

        function showNotification(message, type = 'info') {
            // Remove existing toast notifications
            document.querySelectorAll('.toast').forEach(toast => {
                const bsToast = bootstrap.Toast.getInstance(toast);
                if (bsToast) bsToast.dispose();
                toast.remove();
            });
            
            const toastTypes = {
                success: { bg: 'bg-success', icon: 'fas fa-check-circle' },
                error: { bg: 'bg-danger', icon: 'fas fa-exclamation-circle' },
                warning: { bg: 'bg-warning', icon: 'fas fa-exclamation-triangle' },
                info: { bg: 'bg-info', icon: 'fas fa-info-circle' }
            };
            
            const toastConfig = toastTypes[type] || toastTypes.info;
            
            const toastContainer = document.getElementById('toast-container') || (() => {
                const container = document.createElement('div');
                container.id = 'toast-container';
                container.className = 'toast-container position-fixed top-0 end-0 p-3';
                container.style.zIndex = '11000';
                document.body.appendChild(container);
                return container;
            })();
            
            const toastElement = document.createElement('div');
            toastElement.className = `toast ${toastConfig.bg} text-white border-0`;
            toastElement.setAttribute('role', 'alert');
            toastElement.innerHTML = `
                <div class="toast-body d-flex align-items-center">
                    <i class="${toastConfig.icon} me-2"></i>
                    <span>${message}</span>
                    <button type="button" class="btn-close btn-close-white ms-auto" data-bs-dismiss="toast"></button>
                </div>
            `;
            
            toastContainer.appendChild(toastElement);
            
            const toast = new bootstrap.Toast(toastElement, {
                autohide: true,
                delay: 3000
            });
            
            toast.show();
            
            // Clean up after toast is hidden
            toastElement.addEventListener('hidden.bs.toast', () => {
                toastElement.remove();
            });
        }

        // Video progress tracking
        let progressTrackingInterval;
        
        function setupVideoProgressTracking(videoPlayer) {
            let lastSavedProgress = 0;
            
            // Clear any existing interval
            if (progressTrackingInterval) {
                clearInterval(progressTrackingInterval);
            }
            
            // Track progress every 10 seconds
            progressTrackingInterval = setInterval(() => {
                if (videoPlayer.currentTime > 0 && currentAnimeInfo && episodes[currentEpisodeIndex]) {
                    const progress = Math.floor(videoPlayer.currentTime);
                    const duration = Math.floor(videoPlayer.duration || 0);
                    
                    // Only save if progress changed by more than 5 seconds
                    if (Math.abs(progress - lastSavedProgress) >= 5) {
                        lastSavedProgress = progress;
                        const episodeNumber = episodes[currentEpisodeIndex].number || currentEpisodeIndex + 1;
                        saveVideoProgress(currentAnimeInfo.info, episodeNumber, progress, duration);
                    }
                }
            }, 10000);
            
            // Save progress when pausing
            videoPlayer.addEventListener('pause', () => {
                if (videoPlayer.currentTime > 0 && currentAnimeInfo && episodes[currentEpisodeIndex]) {
                    const progress = Math.floor(videoPlayer.currentTime);
                    const duration = Math.floor(videoPlayer.duration || 0);
                    const episodeNumber = episodes[currentEpisodeIndex].number || currentEpisodeIndex + 1;
                    saveVideoProgress(currentAnimeInfo.info, episodeNumber, progress, duration);
                }
            });
            
            // Save progress when video ends
            videoPlayer.addEventListener('ended', () => {
                if (currentAnimeInfo && episodes[currentEpisodeIndex]) {
                    const duration = Math.floor(videoPlayer.duration || 0);
                    const episodeNumber = episodes[currentEpisodeIndex].number || currentEpisodeIndex + 1;
                    saveVideoProgress(currentAnimeInfo.info, episodeNumber, duration, duration);
                }
            });
        }
        
        async function saveVideoProgress(animeInfo, episode, progress, duration) {
            if (!currentUser) return;
            
            try {
                await fetch(`${API_BASE_URL}/api/recently-played`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        id: animeInfo.id,
                        title: animeInfo.name,
                        poster: animeInfo.poster,
                        episode: episode,
                        progress: progress,
                        duration: duration
                    })
                });
            } catch (error) {
                console.error('Failed to save progress:', error);
            }
        }
        
        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            
            if (hours > 0) {
                return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            return `${minutes}:${secs.toString().padStart(2, '0')}`;
        }

        // SweetAlert popup functions
        function showAnimePopup(animeId, animeName, poster, releaseDate, type) {
            const decodedName = decodeURIComponent(animeName);
            document.getElementById('searchResults').style.display = 'none';
            
            showCustomPopup({
                title: decodedName,
                content: `
                    <div class="anime-details">
                        <img src="${poster}" alt="${decodedName}" class="anime-detail-poster">
                        <div class="anime-detail-info">
                            <p><strong>Release:</strong> ${releaseDate}</p>
                            <p><strong>Type:</strong> ${type}</p>
                        </div>
                    </div>
                `,
                buttons: [
                    {
                        text: '🎬 Watch Now',
                        class: 'btn-primary',
                        action: () => {
                            closeCustomPopup();
                            openAnime(animeId);
                        }
                    },
                    {
                        text: '❌ Cancel',
                        class: 'btn-secondary',
                        action: () => closeCustomPopup()
                    }
                ]
            });
        }
        
        async function showRecentlyPlayedPopup() {
            const recentlyPlayed = await getRecentlyPlayed();
            
            if (recentlyPlayed.length === 0) {
                showCustomPopup({
                    title: 'Recently Played',
                    content: '<div class="no-data"><i class="fas fa-info-circle"></i><p>No recently played episodes found.</p></div>',
                    buttons: [{
                        text: 'OK',
                        class: 'btn-primary',
                        action: () => closeCustomPopup()
                    }]
                });
                return;
            }
            
            const htmlContent = `
                <div class="recent-episodes-list">
                    ${recentlyPlayed.map((item, index) => {
                        const progress = item.progress || 0;
                        const duration = item.duration || 0;
                        const progressPercent = duration > 0 ? Math.min((progress / duration) * 100, 100) : 0;
                        const isCompleted = progressPercent >= 95;
                        const progressText = duration > 0 ? 
                            (isCompleted ? 'Completed' : `${formatTime(progress)} / ${formatTime(duration)}`) 
                            : 'Not started';
                        
                        return `
                            <div class="recent-episode-item" data-anime-id="${item.id}" data-episode="${item.episode}" data-progress="${progress}" style="animation-delay: ${index * 0.1}s">
                                <img src="${item.poster}" alt="${item.title.replace(/"/g, '&quot;')}" class="recent-episode-poster">
                                <div class="recent-episode-info">
                                    <div class="recent-episode-title">${item.title}</div>
                                    <div class="recent-episode-number">Episode ${item.episode}</div>
                                    <div class="recent-episode-progress-text">${progressText}</div>
                                    ${duration > 0 ? `
                                        <div class="recent-episode-progress-bar">
                                            <div class="recent-episode-progress-fill" style="width: ${progressPercent}%"></div>
                                        </div>
                                    ` : ''}
                                </div>
                                ${!isCompleted && progress > 30 ? '<div class="resume-badge">Resume</div>' : ''}
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
            
            showCustomPopup({
                title: '🕒 Recently Played',
                content: htmlContent,
                buttons: [{
                    text: 'Close',
                    class: 'btn-secondary',
                    action: () => closeCustomPopup()
                }],
                size: 'large',
                onOpen: () => {
                    // Add event listeners to recently played items
                    const items = document.querySelectorAll('.recent-episode-item');
                    items.forEach(item => {
                        item.addEventListener('click', function() {
                            const animeId = this.dataset.animeId;
                            const episode = this.dataset.episode;
                            const progress = parseInt(this.dataset.progress || '0');
                            playFromPopupWithProgress(animeId, episode, progress);
                        });
                    });
                }
            });
        }

        // Favorites functionality
        async function getFavorites() {
            if (!currentUser) return [];
            
            try {
                const response = await fetch(`${API_BASE_URL}/api/favorites`, {
                    credentials: 'include'
                });
                
                if (response.ok) {
                    const result = await response.json();
                    return result.data || [];
                }
                return [];
            } catch (error) {
                console.error('Error fetching favorites:', error);
                return [];
            }
        }

        async function addToFavorites(animeData) {
            if (!currentUser) {
                showNotification('Please login to add to favorites', 'warning');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE_URL}/api/favorites`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        id: animeData.id,
                        title: animeData.title || animeData.name,
                        poster: animeData.poster || animeData.image,
                        releaseDate: animeData.releaseDate || animeData.releasedDate,
                        type: animeData.type
                    })
                });
                
                const result = await response.json();
                if (response.ok) {
                    showNotification('Added to favorites!', 'success');
                    updateFavoriteIcons();
                    return result.data;
                } else if (response.status === 409) {
                    showNotification('Already in favorites', 'info');
                } else {
                    throw new Error(result.message || 'Failed to add to favorites');
                }
            } catch (error) {
                console.error('Error adding to favorites:', error);
                showNotification('Failed to add to favorites', 'error');
            }
        }

        async function removeFromFavorites(animeId) {
            if (!currentUser) return;
            
            try {
                const response = await fetch(`${API_BASE_URL}/api/favorites/${animeId}`, {
                    method: 'DELETE',
                    credentials: 'include'
                });
                
                if (response.ok) {
                    showNotification('Removed from favorites', 'success');
                    updateFavoriteIcons();
                    return true;
                }
                throw new Error('Failed to remove from favorites');
            } catch (error) {
                console.error('Error removing from favorites:', error);
                showNotification('Failed to remove from favorites', 'error');
            }
        }

        async function updateFavoriteIcons() {
            if (!currentUser) return;
            
            try {
                const favorites = await getFavorites();
                const favoriteIds = new Set(favorites.map(f => f.id));
                
                // Update all heart icons
                document.querySelectorAll('.favorite-btn').forEach(btn => {
                    const animeId = btn.dataset.animeId;
                    if (favoriteIds.has(animeId)) {
                        btn.innerHTML = '<i class="fas fa-heart"></i>';
                        btn.classList.add('favorited');
                    } else {
                        btn.innerHTML = '<i class="far fa-heart"></i>';
                        btn.classList.remove('favorited');
                    }
                });
            } catch (error) {
                console.error('Error updating favorite icons:', error);
            }
        }

        async function showFavoritesPopup() {
            const favorites = await getFavorites();
            
            if (favorites.length === 0) {
                showCustomPopup({
                    title: '💖 My Favorites',
                    content: '<div class="no-data"><i class="fas fa-heart-broken"></i><p>No favorite anime found. Start adding some!</p></div>',
                    buttons: [{
                        text: 'OK',
                        class: 'btn-primary',
                        action: () => closeCustomPopup()
                    }]
                });
                return;
            }
            
            const htmlContent = `
                <div class="favorites-list">
                    ${favorites.map((item, index) => `
                        <div class="favorite-anime-item" data-anime-id="${item.id}" style="animation-delay: ${index * 0.1}s">
                            <img src="${item.poster}" alt="${item.title.replace(/"/g, '&quot;')}" class="favorite-anime-poster">
                            <div class="favorite-anime-info">
                                <div class="favorite-anime-title">${item.title}</div>
                                <div class="favorite-anime-details">${item.releaseDate} • ${item.type}</div>
                                <div class="favorite-anime-actions">
                                    <button class="btn-primary watch-btn" onclick="playFavoriteAnime('${item.id}')">
                                        <i class="fas fa-play"></i> Watch
                                    </button>
                                    <button class="btn-secondary remove-btn" onclick="removeFavoriteFromList('${item.id}')">
                                        <i class="fas fa-trash"></i> Remove
                                    </button>
                                </div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
            
            showCustomPopup({
                title: '💖 My Favorites',
                content: htmlContent,
                buttons: [{
                    text: 'Close',
                    class: 'btn-secondary',
                    action: () => closeCustomPopup()
                }],
                size: 'large'
            });
        }

        function playFavoriteAnime(animeId) {
            closeCustomPopup();
            openAnime(animeId);
        }

        async function removeFavoriteFromList(animeId) {
            await removeFromFavorites(animeId);
            // Refresh the favorites popup
            setTimeout(() => showFavoritesPopup(), 500);
        }

        async function toggleFavorite(animeData) {
            if (!currentUser) {
                showNotification('Please login to use favorites', 'warning');
                return;
            }

            try {
                const favorites = await getFavorites();
                const isCurrentlyFavorited = favorites.some(f => f.id === animeData.id);
                
                if (isCurrentlyFavorited) {
                    await removeFromFavorites(animeData.id);
                } else {
                    await addToFavorites(animeData);
                }
            } catch (error) {
                console.error('Error toggling favorite:', error);
            }
        }
        
        // Custom Popup System
        function showCustomPopup(options) {
            const overlay = document.getElementById('customPopupOverlay');
            const popup = document.getElementById('customPopup');
            const title = document.getElementById('customPopupTitle');
            const content = document.getElementById('customPopupContent');
            const buttons = document.getElementById('customPopupButtons');
            
            // Set title
            title.textContent = options.title || 'Popup';
            
            // Set content
            content.innerHTML = options.content || '';
            
            // Set size
            popup.className = 'custom-popup';
            if (options.size === 'fullscreen') {
                popup.classList.add('fullscreen');
            } else if (options.size === 'large') {
                popup.classList.add('large');
            }
            
            // Set buttons
            buttons.innerHTML = '';
            if (options.buttons && options.buttons.length > 0) {
                options.buttons.forEach(button => {
                    const btn = document.createElement('button');
                    btn.className = `popup-btn ${button.class || 'btn-primary'}`;
                    btn.textContent = button.text;
                    btn.onclick = button.action;
                    buttons.appendChild(btn);
                });
            }
            
            // Show popup with optimized animation
            overlay.style.display = 'flex';
            document.body.style.overflow = 'hidden';
            
            // Use requestAnimationFrame for smoother animation
            requestAnimationFrame(() => {
                overlay.classList.add('show');
                popup.classList.add('show');
                
                // Call onOpen callback after transition
                if (options.onOpen) {
                    setTimeout(options.onOpen, 100);
                }
            });
        }
        
        function closeCustomPopup() {
            const overlay = document.getElementById('customPopupOverlay');
            const popup = document.getElementById('customPopup');
            
            // Add exit animation
            popup.classList.add('hide');
            overlay.classList.remove('show');
            
            // Wait for transition to complete before hiding
            setTimeout(() => {
                overlay.style.display = 'none';
                popup.classList.remove('show', 'hide');
                document.body.style.overflow = '';
            }, 400);
        }
        
        function playFromPopup(animeId, episode) {
            closeCustomPopup();
            loadAnimeAndPlay(animeId, episode);
        }
        
        function playFromPopupWithProgress(animeId, episode, progress) {
            closeCustomPopup();
            loadAnimeAndPlay(animeId, episode, progress);
        }
        
        async function showTrendingPopup() {
            showCustomPopup({
                title: '🔥 Trending Anime',
                content: '<div id="popup-content"><div class="insane-loading"><div class="loading-rings"><div></div><div></div><div></div></div><p>Loading trending anime...</p></div></div>',
                buttons: [{
                    text: 'Close',
                    class: 'btn-secondary',
                    action: () => closeCustomPopup()
                }],
                size: 'fullscreen',
                onOpen: () => {
                    loadSectionData('trending');
                }
            });
        }
        
        async function showPopularPopup() {
            showCustomPopup({
                title: '⭐ Popular Anime',
                content: '<div id="popup-content"><div class="insane-loading"><div class="loading-rings"><div></div><div></div><div></div></div><p>Loading popular anime...</p></div></div>',
                buttons: [{
                    text: 'Close',
                    class: 'btn-secondary',
                    action: () => closeCustomPopup()
                }],
                size: 'fullscreen',
                onOpen: () => {
                    loadSectionData('popular');
                }
            });
        }
        
        async function showRecentPopup() {
            showCustomPopup({
                title: '🕒 Recent Episodes',
                content: '<div id="popup-content"><div class="insane-loading"><div class="loading-rings"><div></div><div></div><div></div></div><p>Loading recent episodes...</p></div></div>',
                buttons: [{
                    text: 'Close',
                    class: 'btn-secondary',
                    action: () => closeCustomPopup()
                }],
                size: 'fullscreen',
                onOpen: () => {
                    loadSectionData('recent');
                }
            });
        }
        
        async function loadSectionData(section) {
            try {
                let data;
                if (section === 'trending') {
                    data = await loadTrending();
                } else if (section === 'popular') {
                    data = await loadPopular();
                } else if (section === 'recent') {
                    data = await loadRecent();
                }
                
                const content = document.getElementById('popup-content');
                if (content && data && data.length > 0) {
                    // Use more efficient batch rendering
                    renderAnimeGridOptimized(content, data.slice(0, 24));
                } else {
                    content.innerHTML = '<div class="insane-no-data"><i class="fas fa-exclamation-triangle"></i><p>No anime found for this section.</p></div>';
                }
            } catch (error) {
                console.error('Error loading section data:', error);
                const content = document.getElementById('popup-content');
                if (content) {
                    content.innerHTML = '<div class="insane-error"><i class="fas fa-times-circle"></i><p>Error loading anime. Please try again.</p></div>';
                }
            }
        }
        
        function renderAnimeGridOptimized(container, animeData) {
            // Create grid container
            const grid = document.createElement('div');
            grid.className = 'insane-anime-grid';
            
            // Create document fragment for better performance
            const fragment = document.createDocumentFragment();
            
            // Render cards in smaller batches to avoid blocking
            const batchSize = 8;
            let currentBatch = 0;
            
            const renderBatch = () => {
                const start = currentBatch * batchSize;
                const end = Math.min(start + batchSize, animeData.length);
                
                for (let i = start; i < end; i++) {
                    const anime = animeData[i];
                    const card = createAnimeCard(anime, i);
                    fragment.appendChild(card);
                }
                
                // Append this batch to grid
                grid.appendChild(fragment.cloneNode(true));
                
                currentBatch++;
                
                // Continue with next batch if there's more data
                if (end < animeData.length) {
                    requestAnimationFrame(renderBatch);
                }
            };
            
            // Clear container and add grid
            container.innerHTML = '';
            container.appendChild(grid);
            
            // Start rendering
            renderBatch();
        }
        
        function createAnimeCard(anime, index) {
            const card = document.createElement('div');
            card.className = 'insane-anime-card';
            card.dataset.animeId = anime.id;
            card.dataset.animeName = (anime.name || anime.title).replace(/"/g, '&quot;');
            card.dataset.poster = anime.poster || anime.image || '';
            card.dataset.release = anime.releaseDate || anime.releasedDate || 'N/A';
            card.dataset.type = anime.type || 'TV';
            card.style.animationDelay = `${index * 0.03}s`; // Further reduced delay for faster loading
            
            const imageContainer = document.createElement('div');
            imageContainer.className = 'insane-card-image';
            
            const img = document.createElement('img');
            img.alt = (anime.name || anime.title).replace(/"/g, '&quot;');
            img.loading = 'lazy';
            img.style.transition = 'transform 0.25s ease, filter 0.25s ease, opacity 0.3s ease';
            
            // Optimized lazy loading with placeholder
            const placeholder = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUwIiBoZWlnaHQ9IjIwMCIgdmlld0JveD0iMCAwIDE1MCAyMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJzaGltbWVyIiB4MT0iMCUiIHkxPSIwJSIgeDI9IjEwMCUiIHkyPSIwJSI+PHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iIzE2MjEzZSIvPjxzdG9wIG9mZnNldD0iNTAlIiBzdG9wLWNvbG9yPSIjMmEzZjVmIi8+PHN0b3Agb2Zmc2V0PSIxMDAlIiBzdG9wLWNvbG9yPSIjMTYyMTNlIi8+PGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0iZ3JhZGllbnRUcmFuc2Zvcm0iIHR5cGU9InRyYW5zbGF0ZSIgdmFsdWVzPSItMTAwIDsgMTAwIDsgLTEwMCIgZHVyPSIycyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiLz48L2xpbmVhckdyYWRpZW50PjwvZGVmcz48cmVjdCB3aWR0aD0iMTUwIiBoZWlnaHQ9IjIwMCIgZmlsbD0idXJsKCNzaGltbWVyKSIvPjwvc3ZnPg==';
            
            if (anime.poster || anime.image) {
                img.src = placeholder;
                img.dataset.src = anime.poster || anime.image;
                img.style.opacity = '0.7';
                
                // Enhanced lazy loading with intersection observer
                if (window.lazyLoadImage) {
                    window.lazyLoadImage(img);
                } else {
                    img.src = anime.poster || anime.image;
                }
                
                img.onload = function() {
                    if (this.src !== placeholder) {
                        this.style.opacity = '1';
                        this.style.filter = 'none';
                    }
                };
            } else {
                img.src = placeholder;
            }
            
            img.onerror = function() {
                this.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUwIiBoZWlnaHQ9IjIwMCIgdmlld0JveD0iMCAwIDE1MCAyMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxNTAiIGhlaWdodD0iMjAwIiBmaWxsPSIjMTYyMTNlIi8+PGNpcmNsZSBjeD0iNzUiIGN5PSI4NSIgcj0iMTUiIGZpbGw9IiM2YjcyODAiLz48cGF0aCBkPSJNNjAgMTAwIEw5MCAxMDAgTDc1IDEyMCBaIiBmaWxsPSIjNmI3MjgwIi8+PHRleHQgeD0iNzUiIHk9IjE1MCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjEwIiBmaWxsPSIjNmI3MjgwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
                this.style.opacity = '0.5';
            };
            
            const overlay = document.createElement('div');
            overlay.className = 'insane-card-overlay';
            overlay.innerHTML = '<div class="insane-play-btn"><i class="fas fa-play"></i></div>';
            
            // Add favorite button
            const favoriteBtn = document.createElement('button');
            favoriteBtn.className = 'favorite-btn';
            favoriteBtn.dataset.animeId = anime.id;
            favoriteBtn.innerHTML = '<i class="far fa-heart"></i>';
            favoriteBtn.onclick = function(e) {
                e.stopPropagation();
                toggleFavorite(anime);
            };
            
            imageContainer.appendChild(img);
            imageContainer.appendChild(overlay);
            imageContainer.appendChild(favoriteBtn);
            
            const info = document.createElement('div');
            info.className = 'insane-card-info';
            info.innerHTML = `
                <h4>${anime.name || anime.title}</h4>
                <p>${anime.releaseDate || anime.releasedDate || 'N/A'} • ${anime.type || 'TV'}</p>
            `;
            
            card.appendChild(imageContainer);
            card.appendChild(info);
            
            // Add click listener directly
            card.addEventListener('click', function() {
                const animeId = this.dataset.animeId;
                closeCustomPopup();
                openAnime(animeId);
            });
            
            return card;
        }
        
        // Smooth scrolling for anchor links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                const href = this.getAttribute('href');
                if (href && href.length > 1 && href !== '#') {
                    e.preventDefault();
                    const target = document.querySelector(href);
                    if (target) {
                        target.scrollIntoView({
                            behavior: 'smooth',
                            block: 'start'
                        });
                    }
                }
            });
        });
    </script>
</body>
</html>
